<!DOCTYPE html>
<html lang=en>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="null">
  <meta name="keywords" content="undefined">
  
    <link rel="icon" href="">
  
  <title>Understanding Event Loop in Javascript</title>
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/atom-one-light.css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
  <script src="/js/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
  <div class="wrapper">
    <div class="default_title">
        <img src="/imgs/mycomputer.png" />
        <h1>stephen&#39;s blog</h1>
    </div>
    <ul class="topbar">
    
        <li>
        <a href="/" class="item-link">首页</a>
        </li>
    
        <li>
        <a href="/about" class="item-link">关于</a>
        </li>
    
    </ul>
    <div class="tag_list">
    <ul id="tag-list">
        <li><a href="/" ><img src="/imgs/disk.png" />(C:)</a>
        <ul>
        
            <li>
            <a href="/tags/js" title="js" rel="6">
                <img src="/imgs/folder.ico" />
                js
            </a>
            </li>    
        
            <li>
            <a href="/tags/nodeJs" title="nodeJs" rel="2">
                <img src="/imgs/folder.ico" />
                nodeJs
            </a>
            </li>    
        
            <li>
            <a href="/tags/源码分析" title="源码分析" rel="2">
                <img src="/imgs/folder.ico" />
                源码分析
            </a>
            </li>    
        
            <li>
            <a href="/tags/algorithm" title="algorithm" rel="1">
                <img src="/imgs/folder.ico" />
                algorithm
            </a>
            </li>    
        
            <li>
            <a href="/tags/translate" title="translate" rel="2">
                <img src="/imgs/folder.ico" />
                translate
            </a>
            </li>    
        
        </ul>
    </ul>
    </div>
    <div class="post_list">
    <ul>
        
            <li>
            <a href="/2017/06/03/2016-NingJS-JSConf-CN-2016-见闻/">
            <img src="/imgs/file.ico" />
                2016 NingJS(JSConf CN 2016) 见闻
            </a>
            </li>
        
            <li>
            <a href="/2017/09/13/A-color-picker-from-the-scratch/">
            <img src="/imgs/file.ico" />
                手把手实现一个 Color-Picker
            </a>
            </li>
        
            <li>
            <a href="/2017/06/13/Hack！如何让Github-Pages支持browser-history/">
            <img src="/imgs/file.ico" />
                Hack！如何让Github Pages支持browser history
            </a>
            </li>
        
            <li>
            <a href="/2017/07/31/LazyMan的几种解法/">
            <img src="/imgs/file.ico" />
                LazyMan的几种解法
            </a>
            </li>
        
            <li>
            <a href="/2017/06/08/Module-exports-vs-Exports-in-Node-js/">
            <img src="/imgs/file.ico" />
                Module.exports vs Exports in Node.js
            </a>
            </li>
        
            <li>
            <a href="/2017/06/11/Understanding-Event-Loop-in-Javascript/">
            <img src="/imgs/file.ico" />
                Understanding Event Loop in Javascript
            </a>
            </li>
        
            <li>
            <a href="/2017/06/17/Rethinking Asynchronous Programming in Javascript/">
            <img src="/imgs/file.ico" />
                Rethinking Asynchronous Programming in Javascript
            </a>
            </li>
        
            <li>
            <a href="/2017/06/09/bootstrap之CSS源码分析/">
            <img src="/imgs/file.ico" />
                bootstrap之CSS源码分析
            </a>
            </li>
        
            <li>
            <a href="/2017/06/10/Web-Real-time-Connection/">
            <img src="/imgs/file.ico" />
                Web Real-time Connection
            </a>
            </li>
        
            <li>
            <a href="/2017/07/15/从jquery源码看无new构造/">
            <img src="/imgs/file.ico" />
                从jquery源码看无new构造
            </a>
            </li>
        
            <li>
            <a href="/2017/06/13/最小编辑距离问题（Edit-Distance/">
            <img src="/imgs/file.ico" />
                最小编辑距离问题(Edit Distance)
            </a>
            </li>
        
            <li>
            <a href="/2017/06/13/深入浅出throttle和debounce/">
            <img src="/imgs/file.ico" />
                深入浅出throttle和debounce
            </a>
            </li>
        
            <li>
            <a href="/2017/06/13/［译］什么时候“不要”用箭头函数/">
            <img src="/imgs/file.ico" />
                ［译］什么时候“不要”用箭头函数
            </a>
            </li>
        
            <li>
            <a href="/2017/06/07/［译］关于vertical-align你应该知道的事/">
            <img src="/imgs/file.ico" />
                ［译］关于vertical-align你应该知道的事
            </a>
            </li>
        
    </ul>
    </div>

    <div class="post_total">
        
            <div class="left">[object Object] object(s)</div>
        
        <div class="right">&nbsp;</div>
    </div>
</div>
  <div class="content">
    <div class="post_title">
      <img src="/imgs/file.png" />
      <h1>Understanding Event Loop in Javascript</h1>
      <a href="/"><div class="btn"><span class="fa fa-times"></span></div></a>
      <div class="btn btn_max"><span class="fa fa-window-maximize"></span></div>
      <div class="btn"><span class="fa fa-window-minimize"></span></div>
    </div>
    <ul class="topbar">
      <li>Sun Jun 11 2017 22:37:38 GMT+0800</li>
    </ul>
    <div class="post_content">
      <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看了 Philip Roberts 关于event-loop的演讲视频收获良多，本文主要是笔者对<code>event loop</code>模型的总结和整理。</p>
<blockquote>
<p>传送门：<br>YouTube: <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="external">Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014</a></p>
</blockquote>
<h2 id="JavaScript-Runtime"><a href="#JavaScript-Runtime" class="headerlink" title="JavaScript Runtime"></a>JavaScript Runtime</h2><p>我们知道web应用在浏览器中运行会涉及到一系列比如JS runtime、event loop、dom、ajax等等技术，而在弄明白event loop之前我们必须先了解一下JS Runtime的基本作用。</p>
<p>如今业内领头的JS Runtime非Chrome的V8莫属了，下图简要的概括了JS Runtime是个什么样子：</p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100802.png" alt=""></p>
<p>其中heap、stack、callback queue、event loop是JS引擎基本的特征，而关于DOM、ajax、Timer等则属于Web APIs。</p>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>JS是单线程的，即只有一个主线程。而当主线程运行时，JS Runtime会产生heap和stack，其中：</p>
<ul>
<li><p>heap: 主要存放着一系列对象，表示的是内存中大未组织的区域，并且不同的浏览器提供不同的优化。</p>
</li>
<li><p>stack : 函数调用时形成的堆栈，我们知道栈这种数据结构是后进先出的，每当函数调用的时候，就将函数（称为帧）压入栈内，函数调用完则从栈内推出。一旦栈空，就会等待callback queue提供下一帧。比如:</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a * b</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> multiply(n,n)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> squared = square(<span class="number">4</span>)</div><div class="line">  <span class="built_in">console</span>.log(squared)</div><div class="line">&#125;</div><div class="line">printSquare(<span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>首先调用printSquare()的时候，创建第一个堆栈帧，包含参数和局部变量，当printSquare()调用square()时，压入第二个堆栈帧，当square()调用multiply()的时候压入第三个堆栈帧，接着函数返回从栈中依次推出。将过程可视化为:</p>
<p><img src="http://7xl0rs.com1.z0.glb.clouddn.com/eventloop2.gif" alt=""></p>
<p>这就是我们所说的调用栈（Call Stack），JS Runtime每次只是逐行执行代码。</p>
<h3 id="Callback-Queue"><a href="#Callback-Queue" class="headerlink" title="Callback Queue"></a>Callback Queue</h3><p>我们知道任务主要分为同步任务（synchronous） 和 异步任务（asynchronous）。同步任务主要是在主线程中执行，而当JS引擎执行异步任务的时候(如setTimeout()、onclick())，浏览器内核相应模块（即WebAPIs）会处理相关的方法，达到触发条件后相关联的回调函数便会添加到Callback Queue中。当执行栈的代码执行完毕就会读取Callback Queue，依次执行相关的回调函数。</p>
<h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h3><p>之所以称为Event loop，是因为JS运行时会创建类似于这样的循环:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(queue.waitForMessage())&#123;</div><div class="line">  queue.processNextMessage();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每执行一次循环体称为一次Tick，每次Tick的过程就是查看Callback Queue中是否有待处理的Message，如果有则取出来放入执行栈中由主线程执行。</p>
<h3 id="WebAPIs"><a href="#WebAPIs" class="headerlink" title="WebAPIs"></a>WebAPIs</h3><p>主要是一些异步操作，比如DOM Binding、ajax、timer，这些异步操作由浏览器内核的webcore来执行。</p>
<h2 id="Block-amp-Non-Block"><a href="#Block-amp-Non-Block" class="headerlink" title="Block &amp; Non-Block"></a>Block &amp; Non-Block</h2><p>没有非常严格的定义什么是阻塞的什么是非阻塞的，不过我们知道JS执行代码是通过Call Stack这项技术，比如以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = $.getSync(<span class="string">'//foo.com'</span>)</div><div class="line"><span class="keyword">var</span> bar = $.getSync(<span class="string">'//bar.com'</span>)</div><div class="line"><span class="keyword">var</span> qux = $.getSync(<span class="string">'//qux.com'</span>)</div><div class="line"><span class="built_in">console</span>.log(foo)</div><div class="line"><span class="built_in">console</span>.log(bar)</div><div class="line"><span class="built_in">console</span>.log(qux)</div></pre></td></tr></table></figure>
<p>foo()压入栈内，调用完后出栈，接着bar压入栈内…</p>
<p>熟悉JS的人都知道这段代码是阻塞的，一个请求完成才会去执行下一个请求。如果在浏览器内，一个页面进行热请求过长，页面其他部分就不能操作，显然这样的用户体验是非常差的，那么解决办法是什么？使用异步回调函数，比如使用setTimeout():</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span>)</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">'Here'</span>)&#125;, <span class="number">5000</span>)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'World'</span>)</div><div class="line"><span class="comment">// 'Hello'</span></div><div class="line"><span class="comment">// 'World'</span></div><div class="line"><span class="comment">// 'Here'</span></div></pre></td></tr></table></figure>
<p>这就是为什么JS不阻塞的原因了，当执行异步函数setTimeout()并不会阻塞下面函数的执行，等异步函数达到触发条件后(上面例子是500ms后)在执行回调函数。那这里就有一个问题，异步函数具体是怎么样工作的呢，调用异步函数后，相应的回调函数又是放在哪？问题的答案就是Event Loop模型。</p>
<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>这里可以使用Phi写的一个可视化工具<a href="https://github.com/latentflip/loupe" target="_blank" rel="external">loupe</a>，具体来看一下上面异步代码是怎么样运作的:</p>
<p><img src="http://7xl0rs.com1.z0.glb.clouddn.com/eventloop3.gif" alt=""></p>
<p>上图中，首先在Call Stack中压入console.log(‘Hello’)的方法，这只是一个普通方法，所以该方法会立即出栈执行。</p>
<p>接着继续往下执行setTimeout()，这是一个WebAPIs的方法，也就是异步方法，JS runtime会将延迟函数交给浏览器内核相应模块处理(这里是timer模块)，然后立即继续往下执行代码。</p>
<p>这时setTimeout()执行5秒后，timer模块检测到延时处理方法到达触发条件，于是将相应的回调函数加入任务队列。而这个时候Call Stack为空，所以通过event loop轮询检查任务队列是否有回调函数，检查到timeout()，将其压入Call Stack，接着检测到console.log(‘Here’)方法继续压入栈，最后出栈执行。</p>
<p>DOM操作、ajax等都是一样的原理，这些都是由浏览器内核相应模块来处理。</p>

    </div>
</div>
  <footer class="footer">
  <p> powered by hexo</p>
</footer>
<script>
  var max = document.getElementsByClassName("btn")[1];
  var min = document.getElementsByClassName("btn")[2];

  function maximize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if (wid > 900) {
      widf = wid * 0.9;
      post.style.width = widf + "px";

      if (wid < 1400) {
        cont.style.width = "99%";
      } else {
        cont.style.width = "99.4%";
      }
    }
  }

  function minimize () {
    var post = document.getElementsByClassName("content")[0];
    var cont = document.getElementsByClassName("post_content")[0];
    var wid = window.innerWidth || document.documentElement.clientWidth || document.getElementsByTagName("body")[0].clientWidth;

    if ( wid > 900 ) {
      post.style.width = "800px";
      cont.style.width = "98.5%";
    }
  }

  max && max.addEventListener('click', maximize, false);
  min && min.addEventListener('click', minimize, false);

</script>
</body>
</html>