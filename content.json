{"meta":{"title":"Stephen's Blog","subtitle":"Keep Calm And Love","description":null,"author":"stephen","url":"stephenliu.site"},"pages":[{"title":"About Me","date":"2017-06-07T13:24:21.000Z","updated":"2017-06-07T13:24:21.000Z","comments":true,"path":"about/index.html","permalink":"stephenliu.site/about/index.html","excerpt":"","text":""}],"posts":[{"title":"深入浅出throttle和debounce","slug":"深入浅出throttle和debounce","date":"2017-06-13T15:37:57.000Z","updated":"2017-06-13T15:39:35.000Z","comments":true,"path":"2017/06/13/深入浅出throttle和debounce/","link":"","permalink":"stephenliu.site/2017/06/13/深入浅出throttle和debounce/","excerpt":"","text":"前言之前我在写一个获取github用户信息小应用的时候，遇到了一个问题： 由于我在input上绑定了keyup的监听事件并且回调执行ajax请求，每按下一次键盘键就会发出一次ajax请求，显然频繁的网络请求会造成很大的性能问题。这里的解决办法就是用函数去抖(debounce)。那么什么是函数去抖？他的基友函数节流(throttle)又是什么？他们有什么区别？他们应用的场景有分别是什么？下面一一来解答。 函数去抖简单来说，函数去抖背后的思想指的是 某函数只有在过完一段时间后并且该段时间内不被调用才会被执行。一旦在指定的时间间隔内调用该函数，该函数就不会被执行。拿上面例子来说，在没有去抖之前: 1234567function ajax(content) &#123; console.log('ajax request ' + content)&#125;var input = document.getElementById('search')input.addEventListener('keyup', function(e) &#123; ajax(e.target.value)&#125;) 可以看到，每按下一次键盘键就会发送一次ajax请求。现在用debounce()方法来改进： jsbin123456789101112131415161718function debounce(func, delay) &#123; return function(args) &#123; var _this = this var _args = args clearTimeout(func.id) func.id = setTimeout(function() &#123; func.call(_this, _args) &#125;, delay) &#125;&#125;function ajax(value) &#123; console.log('ajax request ' + value)&#125;var debounceAjax = debounce(ajax, 1000)var input = document.getElementById('search')input.addEventListener('keyup', function(e) &#123; debounceAjax(e.target.value)&#125;) 可以看到当你键入值的时候，并不会发送ajax请求，当停止输入并且在指定间隔内没有输入的时候，才会执行相应的回调函数。下面我们来讲讲他的好基友，函数节流(throttle)。 函数节流函数节流指的是 某函数在指定的一个时间段周期性的间断执行。 什么意思呢，举上面的例子，当在input中不断键入数值的时候，debounce是在你停止输入一段时间后执行回调函数，而throttle则是在你输入过程中每隔一段固定的时间就执行回调函数。 jsbin 1234567891011121314151617181920212223242526function throttle(func, delay) &#123; var last, deferTimer return function() &#123; var _this = this var _args = arguments var now = +new Date() if(last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function() &#123; last = now func.apply(_this, _args) &#125;, delay) &#125;else &#123; last = now func.apply(_this, _args) &#125; &#125;&#125;function ajax(value) &#123; console.log('ajax request ' + value)&#125;var throttleAjax = throttle(ajax, 1000)var input = document.getElementById('search')input.addEventListener('keyup', function(e) &#123; throttleAjax(e.target.value)&#125;) 可以看出，当我在input中不断键入值时，ajax回调函数每过1s执行一次。 异同从上面的内容可以知道，函数去抖和函数分流都是解决某一事件频繁触发的问题，比如input的ajax请求、scroll事件等等。即使如此，他们的实现原理却大相庭径，简单来说，函数去抖在一段时间只执行一次，而函数节流则是间隔时间段执行。比如，小明吃饼干，有两种吃法，第一种是每过一段时间间隔吃一块饼干，这是函数节流，第二种是第一块饼干吃完后得过一段时间才能吃第二块饼干，期间不能吃饼干，这是函数去抖。 应用场景 发送一个ajax表单，给一个button绑定click事件，并且监听触发ajax请求。如果是debounce，则用户不管点多少次，都只会发送一次请求；如果是throttle，不断点击的过程中会间隔发送请求。这时候最好使用debounce. 监听滚动事件判断是否到页面底部自动加载更多，如果是debounce，则只有在用户停止滚动的时候的才会判断是否到了底部，如果是throttle，则页面滚动的过程中会间隔判断是否到达底部。 此时最好使用throttle其他 DOM 元素的拖拽功能实现（mousemove） 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹） 计算鼠标移动的距离（mousemove） Canvas 模拟画板功能（mousemove） 搜索联想（keyup） 参考: https://github.com/hanzichi/underscore-analysis/issues/20","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"js","slug":"js","permalink":"stephenliu.site/tags/js/"}]},{"title":"最小编辑距离问题(Edit Distance)","slug":"最小编辑距离问题（Edit-Distance","date":"2017-06-13T15:26:04.000Z","updated":"2017-06-13T15:27:17.000Z","comments":true,"path":"2017/06/13/最小编辑距离问题（Edit-Distance/","link":"","permalink":"stephenliu.site/2017/06/13/最小编辑距离问题（Edit-Distance/","excerpt":"","text":"前言最近在研究react-diff算法的时候，遇到了两个Virtual DOM列表的Diff，其实就是典型的最小编辑距离(Edit Distance)问题，于是抱着强烈的好奇心去研究了一番并做个总结。 定义什么是编辑距离？简单来说就是两个字符串之间，一个转成另一个的最少编辑操作次数，也就是说编辑距离是衡量两个字符串相似性的度量方法，距离越小相似度越大，而其中允许编辑的操作有：插入（insert），删除（delete）以及替换（substitution）。 这里可以看具体问题的描述（摘自leetcode）： Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character 思路具体思路如下图：假设字符串X的长度为N,字符串Y的长度为M，D(i,j)表示字符串X[1...i]转换为Y[1...j]的编辑距离： 注意： 其中X[i]和Y[j]表示字符串X和Y的最后一位 初始化: D(i,0) = i，表示Y字符串为空，X[1…i]全部删除，所以编辑距离为iD(0,j) = j，表示X字符串为空，新插入Y[1…j]，所以编辑距离为j 递归关系: 例子中 &gt;&gt; 定义为字符串转换 当X[i]与Y[j]相等时，此时D(i,j) = D(i-1,j-1)，比如 xyz &gt;&gt; thz 与 xy &gt;&gt; th 的编辑距离相等。 当X[i]与Y[j]不相等时，取下面三项的最小值： D(i-1,j) + 1，即删除X[i]，编辑距离+1，比如xyz &gt;&gt; thx = xy &gt;&gt; thx + 1 D(i,j-1) + 1，即插入Y[j]，转换后编辑距离+1，比如 xyz &gt;&gt; thx = xyzx &gt;&gt; thx + 1 = xyz &gt;&gt; th + 1 D(i-1,j-1) + 2，即X[i]替换成Y[j]，比如xyz &gt;&gt; thx = xyx &gt;&gt; thx + 2 = xy &gt;&gt; th + 2 最后求的这三项的最小值就是编辑距离。 递归算法我们按照上面的思路用代码实现： 12345678910111213141516171819202122const editDistance = ( word1, word2, i, j ) =&gt; &#123; const len1 = word1.length const len2 = word2.length const d = [] if(len1 === 0) &#123; return len2 &#125;else if(len2 === 0) &#123; return len1 &#125;else if(word1[i-1] === word2[j-1])&#123; return editDistance(word1,word2,i-1,j-1) &#125;else&#123; return Math.min(editDistance(word1,word2,i-1,j) + 1, editDistance(word1,word2,i,j-1) + 1, editDistance(word1,word2,i-1,j-1) + 2 ) &#125;&#125; 显然这样写的代码，性能是一个很大的问题，时间复杂度是随指数增长的，所以解决该问题的办法是使用动态规划求解。 动态规划算法我们可以用动态规划的方法来优化时间复杂度以word1为‘sot’，word2为‘stop’为例，我们首先创建一个矩阵： 计算 i=1,j=1: 得到: 计算i=1,j=2: 得到： 最终得到 于是可以得到最短编辑距离为d[m][n] = 3，现在时间复杂度控制在了O(mn)。 具体算法如下： 1234567891011121314151617181920212223242526272829const editDistance = ( word1, word2) =&gt; &#123; const len1 = word1.length const len2 = word2.length let d = [] let i,j for(i = 0; i &lt;= len1; i++)&#123; d[i] = [] d[i][0] = i &#125; for(j = 0; j &lt;= len2; j++)&#123; d[0][j] = j &#125; for(i = 1; i&lt;= len1; i++)&#123; for(j = 1; j &lt;= len2; j++)&#123; if(word1[i-1] == word2[j-1])&#123; d[i][j] = d[i-1][j-1] &#125;else&#123; d[i][j] = Math.min(d[i-1][j]+1,d[i][j-1]+1,d[i-1][j-1]+2) &#125; &#125; &#125; return d[len1][len2]&#125; 参考 stanford - Minimum&amp;Edit&amp;Distance 最小编辑距离算法","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"stephenliu.site/tags/algorithm/"}]},{"title":"［译］什么时候“不要”用箭头函数","slug":"［译］什么时候“不要”用箭头函数","date":"2017-06-13T15:12:35.000Z","updated":"2017-06-13T15:13:08.000Z","comments":true,"path":"2017/06/13/［译］什么时候“不要”用箭头函数/","link":"","permalink":"stephenliu.site/2017/06/13/［译］什么时候“不要”用箭头函数/","excerpt":"","text":"本文翻译于 https://rainsoft.io/when-not-to-use-arrow-functions-in-javascript/ 看到你写的编程语言每天都在进化更新，是一件非常值得高兴的事情，通过从错误中学习、发现更好的解决办法以及创造出新的特性，来让这个过程不断的版本迭代。 近几年这些都发生在Javascrpit身上，尤其是ECMAScript6的出现给这门语言带来了更高的实用性： 箭头函数、类以及更多，这是非常棒的！ 其中最有价值的特性之一便是箭头函数。同时有大量的文章来描述它的上下文透明性以及短语法。如果你是新接触ES6的话，可以从这篇文章来了解箭头函数。 但是水能载舟，也能覆舟。许多时候新特性会介绍的非常混乱，其中之一就是箭头函数被误用。 这篇文章通过情景引导你哪里需要绕过箭头函数，使用更合适的旧的函数表达式或新的短语法。同时对短语法有个心理准备，因为它会影响你代码的可读性。 1.在对象上定义方法在javascript中，方法是储存在对象一个属性里的一个函数。当调用该方法的时候，this指向的是方法所属的对象。 1a.对象字面量自从箭头函数有了短语法，使用它来定义方法变得更加吸引人，让我们尝试一下： 使用JS Bin尝试 12345678910var calculate = &#123; array: [1, 2, 3], sum: () =&gt; &#123; console.log(this === window); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;console.log(this === window); // =&gt; true // Throws \"TypeError: Cannot read property 'reduce' of undefined\"calculate.sum(); calculate.sum方法是使用箭头函数定义的，但是在调用calculate.sum的时候却抛出TypeError的错误，这是因为this.array的值是undefined.当调用calculate对象上的sum()方法的时候，上下文依然是window,原因是箭头函数绑定了window对象的词法上下文。执行this.array相当于执行window.array，它的值是undefined. 解决办法是使用函数表达式或者短语法（ECMAScript 6中可用）来定义方法。在这种情况下this指向的是调用对象，而不是邻近上下文。让我们来看看修改的版本: 使用JS Bin尝试 12345678var calculate = &#123; array: [1, 2, 3], sum() &#123; console.log(this === calculate); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;calculate.sum(); // =&gt; 6 因为sum是一个普通函数，调用calculate.sum()其中的this指向的是calculate对象，this.array便是array的一个引用，所以元素之和计算正确： 6 。 1b.对象原型相同的规则也适用于通过原型对象来定义方法。如下面例子，如果使用箭头函数来定义sayCatName方法，会指向一个不正确的上下文window： 使用JS Bin尝试 123456789function MyCat(name) &#123; this.catName = name;&#125;MyCat.prototype.sayCatName = () =&gt; &#123; console.log(this === window); // =&gt; true return this.catName;&#125;;var cat = new MyCat('Mew'); cat.sayCatName(); // =&gt; undefined 使用保守派的函数表达式: 使用JS Bin尝试 123456789function MyCat(name) &#123; this.catName = name;&#125;MyCat.prototype.sayCatName = function() &#123; console.log(this === cat); // =&gt; true return this.catName;&#125;;var cat = new MyCat('Mew'); cat.sayCatName(); // =&gt; 'Mew' 当你调用cat.sayCatName()方法的时候，sayCatName这个普通函数将上下文改变成了cat对象。 2.结合动态上下文的回调函数this是javascript中一个非常强大的特性。它允许通过函数调用的方式来改变上下文。通常来说，使上下文为函数调用时候的目标对象，会让代码更加自然化，也就是说“让事情发生在对象上”。 然而，箭头函数在声明的时候是静态的绑定上下文，不可能是动态的。这种情况下this是不必要的。 在客户端编程中，给DOM元素绑定监听事件是一个十分常见的事情，一个事件以this作为目标元素去触发事件处理函数，是动态上下文最简便的用法。 下面的例子是使用箭头函数来作为事件处理函数： 使用JS Bin尝试 12345var button = document.getElementById('myButton'); button.addEventListener('click', () =&gt; &#123; console.log(this === window); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 上面的例子中，箭头函数中的this指向的是window，也就是被定义在了全局的上下文。当一个点击事件发生时，浏览器尝试去调用button上下文中的事件处理函数，但是此时箭头函数并没有改变它之前定义的上下文（译者注：也就是window）。 所以，this.innerHTML的值和window.innerHTML的相等，这是没意义的。 你不得不使用函数表达式，来允许你改变this所指向的上下文。 使用JS Bin尝试 12345var button = document.getElementById('myButton'); button.addEventListener('click', function() &#123; console.log(this === button); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 当用户点击按钮，事件处理函数中的this指向的是button。所以this.innnerHTML = &#39;Click Button&#39;正确的的修改了按钮的文本，并且反映了点击的状态。 3. 调用构造器this在构造调用中会指向一个新创建的对象。当执行new MyFunction()的时候，构造函数MyFunction的上下文是一个新的对象： this instanceof MyFunction === true.注意到箭头函数不能用在构造器上，Javascript会通过抛出异常来隐式的预防这个。无论如何，this会指向邻近的上下文而不是新创建的对象。换句话说，一个箭头函数的构造器并没有什么意义，相反可能会造成歧义。让我们来看看如果使用箭头函数构造器: 使用JS Bin尝试 12345var Message = (text) =&gt; &#123; this.text = text;&#125;;// Throws \"TypeError: Message is not a constructor\"var helloMessage = new Message('Hello World!'); Message是一个箭头函数，如果执行new Message(&#39;Hello World!&#39;) ，Javascript会抛出一个TypeError，也就是说Message不能当做构造器。我认为相对于之前javascript版本的静默失败，ECMAScript 6 在这种情况下提供提供包含错误信息的失败提示会是更佳高效的实践。 上面的例子可以通过一个函数表达式来修正，这是一种正确的方式（包括函数声明）来创建构造器： 使用JS Bin尝试 12345var Message = function(text) &#123; this.text = text;&#125;;var helloMessage = new Message('Hello World!'); console.log(helloMessage.text); // =&gt; 'Hello World!' 4.最短语法箭头函数有个非常棒的属性，即可以省略参数的括号，如果函数体只有一条语句，可以省略代码块的花括号{}以及return。这可以帮助你写更短的函数。 曾经我的大学编程老师给学生布置了一个非常有趣的任务：使用C语言通过一个最短的函数来计算字符串的长度。这是学习和探索新语言一个非常好的途径。 尽管如此在现实世界中你的应用代码会被许多开发者阅读。最短语法不是一直都适合给你的同事快速理解函数的意思。 某种程度上来说，压缩函数会让阅读变得更为困难，所以别在这里投入太大的热情。让我们来看看这个例子： 使用JS Bin尝试 1234let multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b; let double = multiply(2); double(3); // =&gt; 6 multiply(2, 3); // =&gt; 6 multiply返回了两个数字相乘的结果或者说为了接下来的运算，关联了第一个参数的闭包。函数运行良好并且看起来非常短，但是它可能在第一眼看的时候比较难的理解。 为了让它的可读性更高，可以给箭头函数添加可选的花括号和return语句或者用一些普通函数： 使用JS Bin尝试 1234567891011function multiply(a, b) &#123; if (b === undefined) &#123; return function(b) &#123; return a * b; &#125; &#125; return a * b;&#125;let double = multiply(2); double(3); // =&gt; 6 multiply(2, 3); // =&gt; 6 最好的方式就是在短和长之间寻找一个平衡点来让你Javascript代码更为简单。 5.结论毫无疑问，箭头函数是一个非常棒的增强特性。如果使用正确的话，它能在很多地方带来便利，比如早期你不得不使用 .bind() 或者试图去捕获上下文。同时它也让代码变得更加轻便。 在一些情况下，优势和劣势是并存的。当要求动态上下文的时候，你就不能使用箭头函数，比如定义方法，用构造器创建对象，当要处理事件时用 this 获取目标。 一些参考文章Gentle explanation of ‘this’ keyword in JavaScriptJavaScript variables hoisting in details The legend of JavaScript equality operator","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"translate","slug":"translate","permalink":"stephenliu.site/tags/translate/"}]},{"title":"Understanding Event Loop in Javascript","slug":"Understanding-Event-Loop-in-Javascript","date":"2017-06-11T14:37:38.000Z","updated":"2017-06-11T14:38:08.000Z","comments":true,"path":"2017/06/11/Understanding-Event-Loop-in-Javascript/","link":"","permalink":"stephenliu.site/2017/06/11/Understanding-Event-Loop-in-Javascript/","excerpt":"","text":"前言前段时间看了 Philip Roberts 关于event-loop的演讲视频收获良多，本文主要是笔者对event loop模型的总结和整理。 传送门：YouTube: Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014 JavaScript Runtime我们知道web应用在浏览器中运行会涉及到一系列比如JS runtime、event loop、dom、ajax等等技术，而在弄明白event loop之前我们必须先了解一下JS Runtime的基本作用。 如今业内领头的JS Runtime非Chrome的V8莫属了，下图简要的概括了JS Runtime是个什么样子： 其中heap、stack、callback queue、event loop是JS引擎基本的特征，而关于DOM、ajax、Timer等则属于Web APIs。 主线程JS是单线程的，即只有一个主线程。而当主线程运行时，JS Runtime会产生heap和stack，其中： heap: 主要存放着一系列对象，表示的是内存中大未组织的区域，并且不同的浏览器提供不同的优化。 stack : 函数调用时形成的堆栈，我们知道栈这种数据结构是后进先出的，每当函数调用的时候，就将函数（称为帧）压入栈内，函数调用完则从栈内推出。一旦栈空，就会等待callback queue提供下一帧。比如: 1234567891011function multiply(a,b)&#123; return a * b&#125;function square(n) &#123; return multiply(n,n)&#125;function printSquare(n)&#123; var squared = square(4) console.log(squared)&#125;printSquare(4) 首先调用printSquare()的时候，创建第一个堆栈帧，包含参数和局部变量，当printSquare()调用square()时，压入第二个堆栈帧，当square()调用multiply()的时候压入第三个堆栈帧，接着函数返回从栈中依次推出。将过程可视化为: 这就是我们所说的调用栈（Call Stack），JS Runtime每次只是逐行执行代码。 Callback Queue我们知道任务主要分为同步任务（synchronous） 和 异步任务（asynchronous）。同步任务主要是在主线程中执行，而当JS引擎执行异步任务的时候(如setTimeout()、onclick())，浏览器内核相应模块（即WebAPIs）会处理相关的方法，达到触发条件后相关联的回调函数便会添加到Callback Queue中。当执行栈的代码执行完毕就会读取Callback Queue，依次执行相关的回调函数。 Event loop之所以称为Event loop，是因为JS运行时会创建类似于这样的循环: 123while(queue.waitForMessage())&#123; queue.processNextMessage();&#125; 每执行一次循环体称为一次Tick，每次Tick的过程就是查看Callback Queue中是否有待处理的Message，如果有则取出来放入执行栈中由主线程执行。 WebAPIs主要是一些异步操作，比如DOM Binding、ajax、timer，这些异步操作由浏览器内核的webcore来执行。 Block &amp; Non-Block没有非常严格的定义什么是阻塞的什么是非阻塞的，不过我们知道JS执行代码是通过Call Stack这项技术，比如以下代码: 123456var foo = $.getSync('//foo.com')var bar = $.getSync('//bar.com')var qux = $.getSync('//qux.com')console.log(foo)console.log(bar)console.log(qux) foo()压入栈内，调用完后出栈，接着bar压入栈内… 熟悉JS的人都知道这段代码是阻塞的，一个请求完成才会去执行下一个请求。如果在浏览器内，一个页面进行热请求过长，页面其他部分就不能操作，显然这样的用户体验是非常差的，那么解决办法是什么？使用异步回调函数，比如使用setTimeout(): 1234567console.log('Hello')setTimeout(function timeout()&#123; console.log('Here')&#125;, 5000)console.log('World')// 'Hello'// 'World'// 'Here' 这就是为什么JS不阻塞的原因了，当执行异步函数setTimeout()并不会阻塞下面函数的执行，等异步函数达到触发条件后(上面例子是500ms后)在执行回调函数。那这里就有一个问题，异步函数具体是怎么样工作的呢，调用异步函数后，相应的回调函数又是放在哪？问题的答案就是Event Loop模型。 Event Loop这里可以使用Phi写的一个可视化工具loupe，具体来看一下上面异步代码是怎么样运作的: 上图中，首先在Call Stack中压入console.log(‘Hello’)的方法，这只是一个普通方法，所以该方法会立即出栈执行。 接着继续往下执行setTimeout()，这是一个WebAPIs的方法，也就是异步方法，JS runtime会将延迟函数交给浏览器内核相应模块处理(这里是timer模块)，然后立即继续往下执行代码。 这时setTimeout()执行5秒后，timer模块检测到延时处理方法到达触发条件，于是将相应的回调函数加入任务队列。而这个时候Call Stack为空，所以通过event loop轮询检查任务队列是否有回调函数，检查到timeout()，将其压入Call Stack，接着检测到console.log(‘Here’)方法继续压入栈，最后出栈执行。 DOM操作、ajax等都是一样的原理，这些都是由浏览器内核相应模块来处理。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"js","slug":"js","permalink":"stephenliu.site/tags/js/"}]},{"title":"Web Real-time Connection","slug":"Web-Real-time-Connection","date":"2017-06-10T15:57:09.000Z","updated":"2017-06-10T15:57:39.000Z","comments":true,"path":"2017/06/10/Web-Real-time-Connection/","link":"","permalink":"stephenliu.site/2017/06/10/Web-Real-time-Connection/","excerpt":"","text":"前言关于web实时通信，我们都知道通常是使用长轮询或者长连接这种方式。 本文是对几种web实时通信进行简单的总结介绍，仅供参考。 Ajax long polling传统的轮询方式是客户端定时(一般使用setInterval)向服务器发送ajax请求，服务器收到请求后马上响应信息。这种方式在客户端和服务端都很好实现，但是会造成很多无用的请求，当服务器没有可返回的数据时，这次请求就浪费了。而长轮询，则是客户端向服务器发送Ajax请求，服务器接到请求后保持住连接，直到有新消息才返回响应信息，客户端处理完响应信息后再向服务器发送新的请求。当然使用长轮询，客户端和服务端需要具备以下的条件: 客户端在收到服务器的响应后，需要向服务器发送新的请求，从而达到轮询的效果 服务器端要能够一直保持住客户端的请求，直到有响应消息；同时服务器对请求的处理要支持非阻塞模式 Server-sent Events(SSE)SSE是HTML5规范的一个组成部分，简单点说，就是客户端向服务端发送一个HTTP请求，然后服务端不断单向地向客户端推送信息(message)。这种信息在格式上也很简单，就是“信息”加上前缀“data: ”，然后以“\\n\\n”结尾: 12345$ curl http://example.com/datesdata: 1394572346452data: 1394572347457data: 1394572348463^C 也就是说，当数据源有新数据的时候，服务器端能立刻发送给一个或多个客户端，而不用等客户端来请求，这些新数据可能是实时新闻、最新股票、上线朋友的聊天信息等等。 Websocket在HTML5中，还提供了一种叫做Websocket的技术，它不仅仅是一种web通信方式，而且也是一种应用层的协议。 它和前文提到的SSE一样都是用来建立客户端和服务端之间的通信渠道，不过两者最大的区别在于： Websocket提供了客户端和服务端之间的全双工跨域通信，在同一时刻能够实现客户端到服务器和服务器到客户端的数据发送;而SSE是单向通道，只能服务器向浏览器端发送; Websocket是一个新的协议（其实是基于TCP协议），需要服务端的支持；而SSE则是部署在HTTP协议之上的 SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。 可以看出，两者虽然功能相似，但是各有特点，适合于不同的场合。关于更多websocket的内容，可以参考websocket.org Socket.io因为不是所有浏览器都支持Websocket标准，所以为了解决这个问题，Socket.io便诞生了。Socket.io是基于node.js生态系统，是对Node.js关于支持WebSocket协议所有API的封装和拓展，完全由js实现。同时，Socket.io设计的目标是支持任何的浏览器和任何设备。于是在接口方面，Socket.io统一了通信的API，在内部支持一系列降级功能： WebSocket AJAX long-polling AJAX multipart streaming Forever Iframe Adobe® Flash® Socket JSONP Polling 也就是说，Socket.io会根据环境来选择适合的通信方式。这点是十分强大的。而搭建Socket.io环境也十分简单，首先需要创建一个作为工作空间的目录，然后安装Node.js，并在工作空间下安装Socket.io(命令：npm install socket.io)，这样环境已经搭建完成。还可以安装基于Node.js框架(如Express.js等)以协助应用的服务器端开发。 具体可以参考我用socket.io &amp;&amp; express 写的一个简易的聊天室程序。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"stephenliu.site/tags/nodeJs/"}]},{"title":"bootstrap之CSS源码分析","slug":"bootstrap之CSS源码分析","date":"2017-06-09T15:24:16.000Z","updated":"2017-06-09T15:24:51.000Z","comments":true,"path":"2017/06/09/bootstrap之CSS源码分析/","link":"","permalink":"stephenliu.site/2017/06/09/bootstrap之CSS源码分析/","excerpt":"","text":"前言Bootstrap作为到目前为止世界上最流行的CSS开发框架吸引了很多开发者。不过对于前端开发者来说，我觉得bootstrap的意义还是在于其代码设计理念以及思路。这篇post主要分析其中的部分CSS源码(版本是bootstrap-4.0.0-alpha，其中CSS具体数据可以通过css stats测得）。Bootstrap3版本之前是基于Less来编译的，但到了4.0-alpha版本就开始正式使用Sass。我们可以看到scss目录结构大致是这样的： 12345678910bootstrap/|– bootstrap.scss # Manifest file |– _alerts.scss # Component file |– _buttons.scss # Component file |– _mixins.scss # Mixin file – imports all files from mixins folder|– ... # Etc..|– mixins/| |– _alerts.scss # Alert mixin| |– _buttons.scss # Button mixin| |– ... # Etc. 从整体的文件结构也可以看出bootstrap组件化以及层次化的特点。接下来我将从三个方面进行分析： CSS Specificity Graph Grid源码分析 Normalize.css CSS Specificity GraphBootstrap中CSS选择器的类型就有两千多种，我们知道在构建自己项目的时候，有一个问题我们必须十分注意：CSS Specificity。这时候我们可以利用一个可视化工具－－CSS Specificity Graph来大致的查看整个项目的CSS Specificity。我认为Bootstrap中CSS Specificity分布还是比较合理的，从整体上看Bootstrap中CSS Specificity大致分布是这样的： 曲线比较粗略的描绘了整个CSS Specificity的分布情况，x轴指的选择器，y轴是权重值。现在我们来分析一下这条曲线，整体上看权重值主要分布在中段（20～30），而最高值达到了60，最低值为1。在前一小段，我们可以清楚的看到权重值普遍低于10，类似于这样类型的选择器： 1234567891011121314151617181920//权重为1html body article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,....//权重为10左右html input[type=&quot;button&quot;], input[type=&quot;reset&quot;],input[type=&quot;submit&quot;],abbr[data-original-title]... 也就是前部分基本上是一些元素或属性选择器。而到了中间有一段平缓区，这部分是栅格系统的选择器: 12345678.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,.col-xs-3,.col-sm-3,.col-md-3,.col-lg-3,.col-xs-4,.col-sm-4,.col-md-4,.col-lg-4,.col-xs-5,.col-sm-5,.col-md-5,.col-lg-5,.col-xs-6,.col-sm-6,.col-md-6,.col-lg-6,.col-xs-7,.col-sm-7,.col-md-7,.col-lg-7,... 随后就是相对复杂的各组件选择器： 12345678910//最低达到10.btn,.btn-link,.form-control,....//最高达到60.btn-group &gt; .btn-group:last-child:not(:first-child) &gt; .btn:first-child.btn-group-vertical &gt; .btn-group:first-child:not(:last-child) &gt; .dropdown-toggle.btn-group &gt; .btn:not(:first-child):not(:last-child):not(.dropdown-toggle)... 总体来说整个曲线是向上的趋势，不过问题也很明显，也就是曲线比较曲折，而我们说一个良好的权重曲线是平缓且向上趋势的，即把权重低的选择器放在最前面，高权重的选择器放在后面，也就是说我们希望曲线不会出现尖峰。由于bootstrap使用的是组件化的思想，所以我们再具体化分别对button、nav、list、table组件进行分析： button组件 nav组件 table组件 list组件 每个组件曲线依然是相对曲折的，不过我们发现CSS Specificity的分布具有一定周期性，尤其是button组件特别明显。原因其实也很简单－－组件中还分为更小的组件(也不完全叫做组件)，比如以button为例： 12345678//.btn还分为更小的部分....btn-primary&#123;&#125;....btn-danger&#123;&#125;....btn-info&#123;&#125;... 这也是为什么每到一个阶段就会出现一个最低点,我们以.btn-primary为例来看一下更为小的组件： 其中源代码为： 123456789101112131415161718192021222324252627282930313233343536373839.btn-primary &#123; color: #fff; background-color: #0275d8; border-color: #0275d8;&#125;.btn-primary:focus,.btn-primary.focus,.btn-primary:active,.btn-primary.active,.open &gt; .btn-primary.dropdown-toggle &#123; color: #fff; background-color: #025aa5; border-color: #01549b;&#125;.btn-primary:hover &#123; color: #fff; background-color: #025aa5; border-color: #01549b;&#125;.btn-primary:active,.btn-primary.active,.open &gt; .btn-primary.dropdown-toggle &#123; background-image: none;&#125;.btn-primary.disabled:focus,.btn-primary.disabled.focus,.btn-primary:disabled:focus,.btn-primary:disabled.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary.focus &#123; background-color: #0275d8; border-color: #0275d8;&#125;.btn-primary.disabled:hover,.btn-primary:disabled:hover,fieldset[disabled] .btn-primary:hover &#123; background-color: #0275d8; border-color: #0275d8;&#125; 从曲线可以看到小组件的趋势是相对平缓且上升的，这也说明bootstrap的权重曲线设计是比较合理的。而我们在构建自己的项目的时候，最合适的模式就是使得项目的CSS Specificity曲线平缓且上升的趋势，避免出现尖峰的情况。想了解更多有关css specificity graph，可以看这篇文章。 Grid System在分析Bootstrap的Grid Systemt之前我们先看一下_variables.scss中所涉及的变量： 12345678910111213141516171819202122232425262728293031//_variables.scss$grid-breakpoints: ( // Extra small screen / phone xs: 0, // Small screen / phone sm: 34em, // Medium screen / tablet md: 48em, // Large screen / desktop lg: 62em, // Extra large screen / wide desktop xl: 75em) !default;// Grid containers// 对于不同的屏幕尺寸设置'.container'的最大宽度$container-max-widths: ( sm: 34rem, // 480 md: 45rem, // 720 lg: 60rem, // 960 xl: 72.25rem // 1140) !default;``` 其中$grid-breakpoints的作用是当你选择哪种方式布局时，从而让Grid系统适应各种屏幕尺寸。我们都知道Grid总列数为12列，列与列的宽度为30px(30px分为两部分，分别应用与相邻的两列),这是通过以下变量定义：```css// Grid columns//// 设置列数以及列与列之间的间隔$grid-columns: 12 !default;$grid-gutter-width: 1.875rem !default; // 30px Bootstrap提供两种布局：固定布局与流式布局,实际上就是在外面加了一个容器(container)，固定布局就是container的宽度时固定的，流式布局的container是自适应的。 12345678910111213141516171819202122232425//_grid.scss// 设置container的固定宽度.container &#123; @include make-container(); //对于不同的屏幕尺寸，通过媒体查询来定义每个container的最大宽度 @each $breakpoint, $container-max-width in $container-max-widths &#123; @include media-breakpoint-up($breakpoint) &#123; max-width: $container-max-width; &#125; &#125;&#125;// Fluid container////利用mixin的方法来设置流式布局.container-fluid &#123; @include make-container();&#125;// Row//// 定义row并且清楚列与列之间的浮动.row &#123; @include make-row();&#125;// Columns@include make-grid-columns(); 再来看一下@mixin make-container和@mixin make-row: 123456789101112131415161718//_grid.scss/mixin@mixin make-container($gutter: $grid-gutter-width) &#123; margin-right: auto; margin-left: auto; padding-left: ($gutter / 2); padding-right: ($gutter / 2); @include clearfix();&#125;@mixin make-row($gutter: $grid-gutter-width) &#123; @if $enable-flex &#123; display: flex; flex-wrap: wrap; &#125; @else &#123; @include clearfix(); &#125; margin-left: ($gutter / -2); margin-right: ($gutter / -2);&#125; row中的负margin是对container的padding修正，为什么要这么做呢？我们可以看一下如何定义col的： 1234567891011@mixin make-col($gutter: $grid-gutter-width) &#123; position: relative; @if $enable-flex &#123; // Do nothing &#125; @else &#123; float: left; &#125; min-height: 1px; padding-left: ($gutter / 2); padding-right: ($gutter / 2);&#125; 这里的col也设置了padding，我们都知道列可以嵌套列，也就是说col里面可以加一层row，这样就使得col相当于一个container，从而实现嵌套，是不是很微妙？具体可以看一下这篇文章 .我们知道bootstrap的列示通过类似.col-xs-1,.col-sm-1,col-md-1,col-lg-1…这样的类名定义的，也就是说class被分为四种分辨率，每种分辨率有12个数字，这样就有48种类名，当然除去pull,push,offset，数量是十分多的。所以为了方便编码，sass用了迭代来产生css。首先通过一个占位符设置通用属性： 123456789// Common properties for all breakpoints%grid-column &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: ($gutter / 2); padding-right: ($gutter / 2);&#125; 然后通过两层迭代来设置col： 1234567@each $breakpoint in map-keys($breakpoints) &#123; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column; &#125; &#125;&#125; 输出结果为： 123456789101112131415161718.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,.col-xs-3,.col-sm-3,.col-md-3,.col-lg-3,.col-xs-4,.col-sm-4,.col-md-4,.col-lg-4,.col-xs-5,.col-sm-5,.col-md-5,.col-lg-5,.col-xs-6,.col-sm-6,.col-md-6,.col-lg-6,.col-xs-7,.col-sm-7,.col-md-7,.col-lg-7,.col-xs-8,.col-sm-8,.col-md-8,.col-lg-8,.col-xs-9,.col-sm-9,.col-md-9,.col-lg-9,.col-xs-10,.col-sm-10,.col-md-10,.col-lg-10,.col-xs-11,.col-sm-11,.col-md-11,.col-lg-11,.col-xs-12,.col-sm-12,.col-md-12,.col-lg-12 &#123; position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px;&#125; 提取出公共属性后，我们需要将其分配到不同分辨率，是怎么做的呢，这里十分巧妙： 12345678910111213141516171819202122232425262728293031%grid-column &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: ($gutter / 2); padding-right: ($gutter / 2); &#125; @each $breakpoint in map-keys($breakpoints) &#123; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column; &#125; &#125; @include media-breakpoint-up($breakpoint) &#123; // Work around cross-media @extend (https://github.com/sass/sass/issues/1050) %grid-column-float-#&#123;$breakpoint&#125; &#123; @if $enable-flex &#123; // Do nothing &#125; @else &#123; float: left; &#125; &#125; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column-float-#&#123;$breakpoint&#125;; @include make-col-span($i, $columns); &#125; &#125; &#125; &#125; 可以看出，它是在遍历分辨率尺寸的基础上，使用定义好的media-breakpoint-up的mixin再进行迭代，这里值得注意的一点是，由于之前我们已经生成了.col-#{$breakpoint}-#{$i}的基本属性，所以在进行查询媒体迭代时，@extend %grid-colum-float-#{$breakpoint}会附加在原有的基本属性上。这样就把各种类名分配到了相应的媒体查询上。当然除此之外，还有push、pull、offset之类的其实也差不多，这里就不再重复了。除此之外有一点人们容易忽略的地方是，Grid系统是基于border-box，这点是实现Grid魔法的关键之一： 12345678html &#123; box-sizing: border-box;&#125;*,*:before,*:after &#123; box-sizing: inherit;&#125; normalize.cssBootstrap中使用normalize.css来初始化样式。之前我一直使用reset.css来重置浏览器的默认样式，而normalize.css是reset.css的一种替代方案。之所称其为替代方案，作者necolas介绍时已经把其说的很清楚了： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 简单点说，它和reset.css不同之处在于： Reset是相对‘暴力’的，不管你有用没用，都重置成统一的样式，所有东西都必须一致。 normalize.css却是相对‘平和’的，不求样式一致,尽量保留浏览器的默认样式，尽量不进行太多的重置。 举个简单的栗子，对于简单的一个 h1 标签来说，reset.css可能会做很多事： 12345678910111213141516171819202122//reset.csshtml, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125;... 而nomalize.css只是这样做： 1234567// Address variable `h1` font-size and margin within `section` and `article`// contexts in Firefox 4+, Safari, and Chrome.//h1 &#123; font-size: 2em; margin: 0.67em 0;&#125; 你可以很轻易的看出其中思想上的差别，也就是说，normalize.css的优势在于它保持了许多浏览器的默认样式，当一个元素在不同浏览器中有不同的默认值时，nomalize.css会让样式保持一致并且尽可能的与现代标准相符合；以及修复了常用的桌面端和移动端浏览器的bug，比如HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 对于使用reset.css还是normalize.css，仁者见仁智者见智吧。 写在后面Bootstrap在设计上是非常注重模块化以及层次化的，一方面是利于维护，另一方面提高了可复用性，这点非常值得学习。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"stephenliu.site/tags/源码分析/"}]},{"title":"Module.exports vs Exports in Node.js","slug":"Module-exports-vs-Exports-in-Node-js","date":"2017-06-07T16:34:42.000Z","updated":"2017-06-07T16:38:47.000Z","comments":true,"path":"2017/06/08/Module-exports-vs-Exports-in-Node-js/","link":"","permalink":"stephenliu.site/2017/06/08/Module-exports-vs-Exports-in-Node-js/","excerpt":"","text":"前言最近在折腾node.js的时候，经常会看到类似exports.xxx = yyy以及module.exports = yyy这样的代码，可实际上如果通过require()函数来引用模块就会有报错的情况，所以到底是什么原因造成的呢？这两者又有什么区别？关于两者的区别，了解了下面几点就会非常的清楚: exports 是 module.exports 的一个引用 exports = module.exports = {} require()返回的是module.exports 而不是 exports exports.xxx 相当于在导出对象上挂属性，该属性对调用模块直接可见exports =相当于给exports对象重新赋值，调用模块不能访问exports 对象及其属性 如果此模块是一个类，就应该直接赋值给module.exports,这样调用者就是一个类构造器，可以直接使用new实例化；如果只导出简单的属性，可以直接挂载到exports上 比如以下代码计算圆的面积： 使用exports12345678// circle.jsexports.area = function(r)&#123; return r*r*3&#125; ;//app.jsvar circle = require('./circle')console.log(circle.area(2))//输出 '12' 使用module.exports12345678// area.jsmodule.exports = function(r)&#123; return r*r*3&#125;;//app.jsvar area = require('./area')console.log(area(2))//输出 '12' 两者输出是一样的，因为exports是module.exports的一个引用，所以两者指向的内存地址是一样的，可是如果你这样写: 12345678// area.jsexports = function(r)&#123; return r*r*3&#125;;//app.jsvar area = require('./area')console.log(area(2))//输出 'TypeError: object is not a function' 我们可以看到是报错的，原因在于，之前说过require()返回的只是module.exports,而exports是module.exports的一个引用，上面代码给exports重新赋值，使其指向了新的内存地址，此时exports和module.exports毫无关系，也就是说此时module.exports的值为默认值{}，所以导出的是一个空对象。 也就是说，module.exports才是关键，而exports只是起辅助的作用,最终导出来的是module.exports上挂载的对象，当module.exports没有任何值时，exports挂载的属性会赋值给module.exports, 当module.exports具有挂载的对象时，exports上的所有值会被忽略，比如以下代码只输出了module.exports所挂载的属性: 12345678//rock.jsmodule.exports.name = 'Stephen'exports.name = 'Mike'//app.jsvar rock = require('./rock.js')rock.name//输出'Stephen' 总结一下: 如果要导出非对象接口（属性），可以直接使用exports 如果要导出对象接口(类)，应该将其挂载到module.exports上面，从而可以直接让调用者new实例化对象 参考：exports 和 module.exports 的区别node-js-exports-vs-module-exportsmodule-exports-and-exports-in-node-js","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"stephenliu.site/tags/nodeJs/"}]},{"title":"［译］关于vertical-align你应该知道的事","slug":"［译］关于vertical-align你应该知道的事","date":"2017-06-07T07:41:19.000Z","updated":"2017-06-07T15:46:02.000Z","comments":true,"path":"2017/06/07/［译］关于vertical-align你应该知道的事/","link":"","permalink":"stephenliu.site/2017/06/07/［译］关于vertical-align你应该知道的事/","excerpt":"","text":"原文链接：Vertical-Align: All You Need To Know原文作者: Christopher Aue 关于Vertical-Align你应该知道的事我经常会碰到将元素在垂直方向上对齐的需求。 CSS提供了一些可能的方法:有时我会用float来解决这个问题,有时会使用position:absolute,有时甚至不惜手动调整margins或者paddings(这是一件十分dirty的做法)。 实话说我非常不喜欢这些解决方式。浮动只在其顶部对齐并且需要手动清除浮动。绝对定位会使元素脱离文档流,以至于它们不再影响它们周边的元素。对于使用固定的margins和paddings来说即使只是一些微小的变化,那也将成为一场灾难。 但是这里有另一个杀伤力武器 : vertical-align。我认为它值得这个称赞。好吧,从技术角度上讲,使用vertical-align来布局其实是一种hack,原因是它存在并不是为了布局。而是为了使文本元素和与相邻的元素在垂直方向上对齐。尽管如此,在不同的上下文你依然可以非常灵活和细粒化的使用vertical-align来对齐元素。元素的尺寸可以不需要知道,因为元素没有脱离文档流,所以其它元素可以对那些改变的尺寸作出反应。这将使他在布局时成为一个有价值的选择。 Vertical-Align的奇特之处尽管如此,vertical-align有时候可能是面目狰狞的。使用它会令人有点泄气:在它的内部工作机制中似乎有一些神秘的规则。比如有一种很可能发生的情况便是,当你改变了某个元素的vertical-align属性,实际上并没有改变它的对齐方式,但别的元素却发生了变化! 不幸的是,当今大部分有关这方面的资料深入程度都不够。尤其是当我们想用vertical-align来布局的时候。这些资料更多的是将注意力集中在一个误解的概念上-尝试着垂直对齐一个元素内的任何内容。他们仅仅给出基本的介绍以及解释在一些十分简单的情况下元素是如何对齐的。他们并不解释复杂的部分。 所以,我给自己设定了一个目标– 彻彻底底的弄清楚vertical-align 的行为 。我参考了W3C上的CSS规范以及试验了一些例子最终结束了这项任务。这篇文章便是我研究的成果。 那么,让我们来弄清楚这个游戏规则吧! 使用Vertical-align的要求 vertical-align被用于对齐inline元素。这些元素,也就是display属性为inline和inline-block,而inline-table的元素不在本文讨论的范围内。Inline元素基本上指的就是文本。 Inline-block元素顾名思义,同时具备inline以及block元素的特性。这样的元素具有宽度和高度(可能是由内容高度决定),同样还具有padding,margin,boreder。inline元素一个一个挨着摆放在行内。一旦元素太多而超出该行,则一个新行会被创建出来,这些行便是所谓的line-box。它会将行内所有的内容包裹起来。不同大小的内容,line-box的行内高度也会不同。下图画的红线代表了line-box的上下边界。 在这些line-box里vertical-align属性负责对齐那些独立的元素。那么,这些元素是和谁对齐呢? 关于Baselines和边界 关于垂直对齐最重要的一点便是相关元素的baseline。有些情况元素盒模型的上下边界也十分重要。让我们来看看每个相关元素中baseline和边界所在的位置。 上图你可以看到有并排的三行文字。行高的上下边界用红线标出,文字高度用的是绿线,baseline便是蓝线了。左图行高和文字高度一致,所以绿线和红线重合了。中间图行高是文字大小的两倍。右边行高是文字大小的二分之一。行内元素的外界在行高的上下边缘这个范围内对齐。如果行高小于文字高度也无所谓。什么是baseline呢?简单粗暴的说,baseline就是文字高度中线下方的一条线。具体可以看W3C上的介绍标准链接。 inline-block元素 从左到右你可以看到三个inline-block元素:左边是没有脱离文档流的内容c,中间是没有脱离文档流的内容c并且overflow:hidden,右边是没有内容但是内容有高度。margin-box的边界是用红线标出,黄色是border,绿色是padding,蓝色是content。蓝色的线代表的是元素的baseline。inline-block元素的边界就是margin-box的上下边界。 inline-block元素的baseline取决于该元素是否具有处于正常流的内容,具体分以下三种情况: 在具有处于文档流的内容的情况下,inline-block元素的baseline就是最后一个内容元素的baseline(如上图左边)。这个元素的baseline的确定根据去自身规则确定。 在具有处于文档流的内容并且overflow属性的值不为visible的情况下,baseline便是margin-box的下边界(如上图中间)。因此它也是inline-block的下边界。 在不具有处于文档流的内容情况下,baseline同样也是margin-box的下边界。 Line box 关于line-box的图上面已经说过了。这次我将linebox的内容的上下边界(绿线)以及baseline(蓝线)画了出来。同样将内容元素用灰色背景高亮了出来。line-box的上边界和最高元素的上边界对齐,下边界和最低元素的下边界对齐。 line-box的baseline是不确定的 CSS2.1 does not define the position of the line box’s baseline ——the W3C Specs* 这也是当我们使用vertical-align时最令人疑惑的地方。这意味着baseline的位置受其他条件比如vertical-align的值以及让line-box高度最小的影响。这是一个很灵活的参数。 因为line-box的baseline是不可见得,所以可能不能一眼就看出来它在那。不过,你可以很轻易的将它可视化出来。只需要在行的开头添加一个字母。比如添加一个’x’。如果这个字母没有被其他方法来对齐,那么它的下边界默认就是baseline的位置。 在line-box中围绕着baseline会形成text-box。text-box可以简单的被认为是没有和line-box中任何元素对齐的inline元素。它的高度与父元素font-size的值相等。因此,text-box仅仅包含非格式化的line-box文本。text-box的边界由绿线来表示。因为text-box和baseline是绑定的,当baseline位置发生变化时它的位置也会发生变化。(这里所说的text-box在W3C标准中被叫做strut。) hu~这部分比较难理解。让我们总结一下最重要的两点: 有一个叫line-box的区域,垂直方向的对齐都发生在这个区域里。它有baseline,text-box以及上下边界。 inline元素是我们需要对其的对象,他们有baseline和上下边界。 Vertical-Align的值 关于Vertical-align的值具体可以看MDN Vertical-Align是如何发挥它的作用的呢我们现在可以更加深入的了解在某些情况下元素是如何垂直对齐的。 对齐一个Icon这里有一个问题：我想将一个icon与相邻的文本对齐。仅仅将icon的vertical-align属性的值设置为middle并不是一个令人满意的方法。看一下例子： 12345678910111213&lt;!-- left mark-up --&gt;&lt;span class=\"icon middle\"&gt;&lt;/span&gt;Centered?&lt;!-- right mark-up --&gt;&lt;span class=\"icon middle\"&gt;&lt;/span&gt;&lt;span class=\"middle\"&gt;Centered!&lt;/span&gt;&lt;style type=\"text/css\"&gt;.icon &#123; display: inline-block; /* size, color, etc. */ &#125;.middle &#123; vertical-align: middle; &#125;&lt;/style&gt; 下面给出上图的辅助线版本: 这揭示了我们的问题。因为左图的文本根本没有发生对齐行为，它还是和line-box的baseline对齐。而vertical-align对齐的点是baseline加上半个x的距离(half of the x-height)。因此文字的最高点超过了icon的高度。右图所示，文字与icon对齐与一个中点。文字的baseline稍微低于line-box的baseline。结果文字很好的和icon对齐了。 关于Line-box的baseline的移动问题这是一个使用vertical-align常有的坑：line-box里的所有元素都会影响到baseline的位置。让我们假设一下，如果一个元素通过某种方法对齐了，但是line-box的baseline不得不因此移动。因为大部分对齐方式（除了top和bottom）都和baseline有关，因此这个元素的对齐会导致行内其他元素的调整。下面是一些例子： 如果有一个高度可以占满整个line-box高度的元素，那么vertical-align对它是没有影响的。在它的top以上和bottom以下没有空间可以使它移动。为了满足它的vertical-align的值，line-box的baseline需要移动。下图矮盒子的vertical-align:baseline,左边的高盒子取值为text-bottom,右边为text-top，你可以看到矮盒子随着baseline跳了上去。 123456789101112131415&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box,.short-box &#123; display: inline-block; /* size, color, etc. */ &#125;.text-bottom &#123; vertical-align: text-bottom; &#125;.text-top &#123; vertical-align: text-top; &#125;&lt;/style&gt; 当把高元素的vertical-align属性设置成其他值的时候，表现的行为是一样的。 甚至将vertical-align设置成bottom（left）和top（right）也会移动baseline。这很奇怪，因为这应该和baseline并没有什么关系。 123456789101112131415&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box,.short-box &#123; display: inline-block; /* size, color, etc. */ &#125;.bottom &#123; vertical-align: bottom; &#125;.top &#123; vertical-align: top; &#125;&lt;/style&gt; 将两个更大的元素放在一行里，然后设置vertical-align的值使其的baseline移动以至于让他们对齐。接着line-box的高度会自动调整。添加第三个元素，这个元素如果不超过line-box的边界，则它不影响line-box的高度以及baseline的位置。如果该元素超过了line-box的边缘，则line-box的高度以及baseline都会调整。在这种情况下，另外两个元素的位置发生了下移。 12345678910111213141516171819202122&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;!-- mark-up in the middle --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box middle\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-100up\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box &#123; display: inline-block; /* size, color, etc. */ &#125;.middle &#123; vertical-align: middle; &#125;.text-top &#123; vertical-align: text-top; &#125;.text-bottom &#123; vertical-align: text-bottom; &#125;.text-100up &#123; vertical-align: 100%; &#125;&lt;/style&gt; inline元素下方可能会有点间隙来看一个例子。一个常见的情况就是你尝试将列表的li元素垂直对齐。 12345678910&lt;ul&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li class=\"box\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style type=\"text/css\"&gt; .box &#123; display: inline-block; /* size, color, etc. */ &#125;&lt;/style&gt; 正如你所看到的，li元素是对齐baseline的。baseline的下方会有一部分留给文字的空间。这便会产生小缝隙。那么解决方案是什么？只要改变line-box的baseline的位置就好了，比如把li元素的vertical-align:middle. 123456789101112&lt;ul&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style type=\"text/css\"&gt; .box &#123; display: inline-block; /* size, color, etc. */ &#125; .middle &#123; vertical-align: middle; &#125;&lt;/style&gt; inline元素之间的间隙会破坏布局效果这主要是inline元素自身的问题。但是因为这是让vertical-align发挥作用的必要因素，所以了解它也是不错的。 这个间隙主要是来源于inline元素之间的空格。所有空白都会变成一个空格。这个空格可以通过该方法反映，比如如果你想让两个inline元素紧挨着，然后给他们的宽度分别设置为50%，这里并没有足够的空间存放两个宽度为50%的元素以及一个空格。所以一行便会被破坏成两行。为了移除空隙，我需要移除空格，解决方案如下： 123456789101112&lt;!-- left mark-up --&gt;&lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;div class=\"half\"&gt;50% wide... and in next line&lt;/div&gt;&lt;!-- right mark-up --&gt; &lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;!----&gt;&lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;style type=\"text/css\"&gt; .half &#123; display: inline-block; width: 50%; &#125;&lt;/style&gt; Vertical-align揭秘是的，对于你来说了解这些规则并不复杂。如果vertical-align不起作用，那么想想看这两个问题： line-box的baseline以及上下边缘位置在哪里？ inline元素的baseline以及上下边缘在哪里？","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"translate","slug":"translate","permalink":"stephenliu.site/tags/translate/"}]}]}