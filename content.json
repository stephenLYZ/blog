{"meta":{"title":"Stephen's Blog","subtitle":"Keep Calm And Love","description":null,"author":"stephen","url":"stephenliu.site"},"pages":[{"title":"About Me","date":"2017-06-07T13:24:21.000Z","updated":"2017-06-07T13:24:21.000Z","comments":true,"path":"about/index.html","permalink":"stephenliu.site/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Understanding Event Loop in Javascript","slug":"Understanding-Event-Loop-in-Javascript","date":"2017-06-11T14:37:38.000Z","updated":"2017-06-11T14:38:08.000Z","comments":true,"path":"2017/06/11/Understanding-Event-Loop-in-Javascript/","link":"","permalink":"stephenliu.site/2017/06/11/Understanding-Event-Loop-in-Javascript/","excerpt":"","text":"前言前段时间看了 Philip Roberts 关于event-loop的演讲视频收获良多，本文主要是笔者对event loop模型的总结和整理。 传送门：YouTube: Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014 JavaScript Runtime我们知道web应用在浏览器中运行会涉及到一系列比如JS runtime、event loop、dom、ajax等等技术，而在弄明白event loop之前我们必须先了解一下JS Runtime的基本作用。 如今业内领头的JS Runtime非Chrome的V8莫属了，下图简要的概括了JS Runtime是个什么样子： 其中heap、stack、callback queue、event loop是JS引擎基本的特征，而关于DOM、ajax、Timer等则属于Web APIs。 主线程JS是单线程的，即只有一个主线程。而当主线程运行时，JS Runtime会产生heap和stack，其中： heap: 主要存放着一系列对象，表示的是内存中大未组织的区域，并且不同的浏览器提供不同的优化。 stack : 函数调用时形成的堆栈，我们知道栈这种数据结构是后进先出的，每当函数调用的时候，就将函数（称为帧）压入栈内，函数调用完则从栈内推出。一旦栈空，就会等待callback queue提供下一帧。比如: 1234567891011function multiply(a,b)&#123; return a * b&#125;function square(n) &#123; return multiply(n,n)&#125;function printSquare(n)&#123; var squared = square(4) console.log(squared)&#125;printSquare(4) 首先调用printSquare()的时候，创建第一个堆栈帧，包含参数和局部变量，当printSquare()调用square()时，压入第二个堆栈帧，当square()调用multiply()的时候压入第三个堆栈帧，接着函数返回从栈中依次推出。将过程可视化为: 这就是我们所说的调用栈（Call Stack），JS Runtime每次只是逐行执行代码。 Callback Queue我们知道任务主要分为同步任务（synchronous） 和 异步任务（asynchronous）。同步任务主要是在主线程中执行，而当JS引擎执行异步任务的时候(如setTimeout()、onclick())，浏览器内核相应模块（即WebAPIs）会处理相关的方法，达到触发条件后相关联的回调函数便会添加到Callback Queue中。当执行栈的代码执行完毕就会读取Callback Queue，依次执行相关的回调函数。 Event loop之所以称为Event loop，是因为JS运行时会创建类似于这样的循环: 123while(queue.waitForMessage())&#123; queue.processNextMessage();&#125; 每执行一次循环体称为一次Tick，每次Tick的过程就是查看Callback Queue中是否有待处理的Message，如果有则取出来放入执行栈中由主线程执行。 WebAPIs主要是一些异步操作，比如DOM Binding、ajax、timer，这些异步操作由浏览器内核的webcore来执行。 Block &amp; Non-Block没有非常严格的定义什么是阻塞的什么是非阻塞的，不过我们知道JS执行代码是通过Call Stack这项技术，比如以下代码: 123456var foo = $.getSync('//foo.com')var bar = $.getSync('//bar.com')var qux = $.getSync('//qux.com')console.log(foo)console.log(bar)console.log(qux) foo()压入栈内，调用完后出栈，接着bar压入栈内… 熟悉JS的人都知道这段代码是阻塞的，一个请求完成才会去执行下一个请求。如果在浏览器内，一个页面进行热请求过长，页面其他部分就不能操作，显然这样的用户体验是非常差的，那么解决办法是什么？使用异步回调函数，比如使用setTimeout(): 1234567console.log('Hello')setTimeout(function timeout()&#123; console.log('Here')&#125;, 5000)console.log('World')// 'Hello'// 'World'// 'Here' 这就是为什么JS不阻塞的原因了，当执行异步函数setTimeout()并不会阻塞下面函数的执行，等异步函数达到触发条件后(上面例子是500ms后)在执行回调函数。那这里就有一个问题，异步函数具体是怎么样工作的呢，调用异步函数后，相应的回调函数又是放在哪？问题的答案就是Event Loop模型。 Event Loop这里可以使用Phi写的一个可视化工具loupe，具体来看一下上面异步代码是怎么样运作的: 上图中，首先在Call Stack中压入console.log(‘Hello’)的方法，这只是一个普通方法，所以该方法会立即出栈执行。 接着继续往下执行setTimeout()，这是一个WebAPIs的方法，也就是异步方法，JS runtime会将延迟函数交给浏览器内核相应模块处理(这里是timer模块)，然后立即继续往下执行代码。 这时setTimeout()执行5秒后，timer模块检测到延时处理方法到达触发条件，于是将相应的回调函数加入任务队列。而这个时候Call Stack为空，所以通过event loop轮询检查任务队列是否有回调函数，检查到timeout()，将其压入Call Stack，接着检测到console.log(‘Here’)方法继续压入栈，最后出栈执行。 DOM操作、ajax等都是一样的原理，这些都是由浏览器内核相应模块来处理。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"js","slug":"js","permalink":"stephenliu.site/tags/js/"}]},{"title":"Web Real-time Connection","slug":"Web-Real-time-Connection","date":"2017-06-10T15:57:09.000Z","updated":"2017-06-10T15:57:39.000Z","comments":true,"path":"2017/06/10/Web-Real-time-Connection/","link":"","permalink":"stephenliu.site/2017/06/10/Web-Real-time-Connection/","excerpt":"","text":"前言关于web实时通信，我们都知道通常是使用长轮询或者长连接这种方式。 本文是对几种web实时通信进行简单的总结介绍，仅供参考。 Ajax long polling传统的轮询方式是客户端定时(一般使用setInterval)向服务器发送ajax请求，服务器收到请求后马上响应信息。这种方式在客户端和服务端都很好实现，但是会造成很多无用的请求，当服务器没有可返回的数据时，这次请求就浪费了。而长轮询，则是客户端向服务器发送Ajax请求，服务器接到请求后保持住连接，直到有新消息才返回响应信息，客户端处理完响应信息后再向服务器发送新的请求。当然使用长轮询，客户端和服务端需要具备以下的条件: 客户端在收到服务器的响应后，需要向服务器发送新的请求，从而达到轮询的效果 服务器端要能够一直保持住客户端的请求，直到有响应消息；同时服务器对请求的处理要支持非阻塞模式 Server-sent Events(SSE)SSE是HTML5规范的一个组成部分，简单点说，就是客户端向服务端发送一个HTTP请求，然后服务端不断单向地向客户端推送信息(message)。这种信息在格式上也很简单，就是“信息”加上前缀“data: ”，然后以“\\n\\n”结尾: 12345$ curl http://example.com/datesdata: 1394572346452data: 1394572347457data: 1394572348463^C 也就是说，当数据源有新数据的时候，服务器端能立刻发送给一个或多个客户端，而不用等客户端来请求，这些新数据可能是实时新闻、最新股票、上线朋友的聊天信息等等。 Websocket在HTML5中，还提供了一种叫做Websocket的技术，它不仅仅是一种web通信方式，而且也是一种应用层的协议。 它和前文提到的SSE一样都是用来建立客户端和服务端之间的通信渠道，不过两者最大的区别在于： Websocket提供了客户端和服务端之间的全双工跨域通信，在同一时刻能够实现客户端到服务器和服务器到客户端的数据发送;而SSE是单向通道，只能服务器向浏览器端发送; Websocket是一个新的协议（其实是基于TCP协议），需要服务端的支持；而SSE则是部署在HTTP协议之上的 SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。 可以看出，两者虽然功能相似，但是各有特点，适合于不同的场合。关于更多websocket的内容，可以参考websocket.org Socket.io因为不是所有浏览器都支持Websocket标准，所以为了解决这个问题，Socket.io便诞生了。Socket.io是基于node.js生态系统，是对Node.js关于支持WebSocket协议所有API的封装和拓展，完全由js实现。同时，Socket.io设计的目标是支持任何的浏览器和任何设备。于是在接口方面，Socket.io统一了通信的API，在内部支持一系列降级功能： WebSocket AJAX long-polling AJAX multipart streaming Forever Iframe Adobe® Flash® Socket JSONP Polling 也就是说，Socket.io会根据环境来选择适合的通信方式。这点是十分强大的。而搭建Socket.io环境也十分简单，首先需要创建一个作为工作空间的目录，然后安装Node.js，并在工作空间下安装Socket.io(命令：npm install socket.io)，这样环境已经搭建完成。还可以安装基于Node.js框架(如Express.js等)以协助应用的服务器端开发。 具体可以参考我用socket.io &amp;&amp; express 写的一个简易的聊天室程序。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"stephenliu.site/tags/nodeJs/"}]},{"title":"bootstrap之CSS源码分析","slug":"bootstrap之CSS源码分析","date":"2017-06-09T15:24:16.000Z","updated":"2017-06-09T15:24:51.000Z","comments":true,"path":"2017/06/09/bootstrap之CSS源码分析/","link":"","permalink":"stephenliu.site/2017/06/09/bootstrap之CSS源码分析/","excerpt":"","text":"前言Bootstrap作为到目前为止世界上最流行的CSS开发框架吸引了很多开发者。不过对于前端开发者来说，我觉得bootstrap的意义还是在于其代码设计理念以及思路。这篇post主要分析其中的部分CSS源码(版本是bootstrap-4.0.0-alpha，其中CSS具体数据可以通过css stats测得）。Bootstrap3版本之前是基于Less来编译的，但到了4.0-alpha版本就开始正式使用Sass。我们可以看到scss目录结构大致是这样的： 12345678910bootstrap/|– bootstrap.scss # Manifest file |– _alerts.scss # Component file |– _buttons.scss # Component file |– _mixins.scss # Mixin file – imports all files from mixins folder|– ... # Etc..|– mixins/| |– _alerts.scss # Alert mixin| |– _buttons.scss # Button mixin| |– ... # Etc. 从整体的文件结构也可以看出bootstrap组件化以及层次化的特点。接下来我将从三个方面进行分析： CSS Specificity Graph Grid源码分析 Normalize.css CSS Specificity GraphBootstrap中CSS选择器的类型就有两千多种，我们知道在构建自己项目的时候，有一个问题我们必须十分注意：CSS Specificity。这时候我们可以利用一个可视化工具－－CSS Specificity Graph来大致的查看整个项目的CSS Specificity。我认为Bootstrap中CSS Specificity分布还是比较合理的，从整体上看Bootstrap中CSS Specificity大致分布是这样的： 曲线比较粗略的描绘了整个CSS Specificity的分布情况，x轴指的选择器，y轴是权重值。现在我们来分析一下这条曲线，整体上看权重值主要分布在中段（20～30），而最高值达到了60，最低值为1。在前一小段，我们可以清楚的看到权重值普遍低于10，类似于这样类型的选择器： 1234567891011121314151617181920//权重为1html body article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,....//权重为10左右html input[type=&quot;button&quot;], input[type=&quot;reset&quot;],input[type=&quot;submit&quot;],abbr[data-original-title]... 也就是前部分基本上是一些元素或属性选择器。而到了中间有一段平缓区，这部分是栅格系统的选择器: 12345678.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,.col-xs-3,.col-sm-3,.col-md-3,.col-lg-3,.col-xs-4,.col-sm-4,.col-md-4,.col-lg-4,.col-xs-5,.col-sm-5,.col-md-5,.col-lg-5,.col-xs-6,.col-sm-6,.col-md-6,.col-lg-6,.col-xs-7,.col-sm-7,.col-md-7,.col-lg-7,... 随后就是相对复杂的各组件选择器： 12345678910//最低达到10.btn,.btn-link,.form-control,....//最高达到60.btn-group &gt; .btn-group:last-child:not(:first-child) &gt; .btn:first-child.btn-group-vertical &gt; .btn-group:first-child:not(:last-child) &gt; .dropdown-toggle.btn-group &gt; .btn:not(:first-child):not(:last-child):not(.dropdown-toggle)... 总体来说整个曲线是向上的趋势，不过问题也很明显，也就是曲线比较曲折，而我们说一个良好的权重曲线是平缓且向上趋势的，即把权重低的选择器放在最前面，高权重的选择器放在后面，也就是说我们希望曲线不会出现尖峰。由于bootstrap使用的是组件化的思想，所以我们再具体化分别对button、nav、list、table组件进行分析： button组件 nav组件 table组件 list组件 每个组件曲线依然是相对曲折的，不过我们发现CSS Specificity的分布具有一定周期性，尤其是button组件特别明显。原因其实也很简单－－组件中还分为更小的组件(也不完全叫做组件)，比如以button为例： 12345678//.btn还分为更小的部分....btn-primary&#123;&#125;....btn-danger&#123;&#125;....btn-info&#123;&#125;... 这也是为什么每到一个阶段就会出现一个最低点,我们以.btn-primary为例来看一下更为小的组件： 其中源代码为： 123456789101112131415161718192021222324252627282930313233343536373839.btn-primary &#123; color: #fff; background-color: #0275d8; border-color: #0275d8;&#125;.btn-primary:focus,.btn-primary.focus,.btn-primary:active,.btn-primary.active,.open &gt; .btn-primary.dropdown-toggle &#123; color: #fff; background-color: #025aa5; border-color: #01549b;&#125;.btn-primary:hover &#123; color: #fff; background-color: #025aa5; border-color: #01549b;&#125;.btn-primary:active,.btn-primary.active,.open &gt; .btn-primary.dropdown-toggle &#123; background-image: none;&#125;.btn-primary.disabled:focus,.btn-primary.disabled.focus,.btn-primary:disabled:focus,.btn-primary:disabled.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary.focus &#123; background-color: #0275d8; border-color: #0275d8;&#125;.btn-primary.disabled:hover,.btn-primary:disabled:hover,fieldset[disabled] .btn-primary:hover &#123; background-color: #0275d8; border-color: #0275d8;&#125; 从曲线可以看到小组件的趋势是相对平缓且上升的，这也说明bootstrap的权重曲线设计是比较合理的。而我们在构建自己的项目的时候，最合适的模式就是使得项目的CSS Specificity曲线平缓且上升的趋势，避免出现尖峰的情况。想了解更多有关css specificity graph，可以看这篇文章。 Grid System在分析Bootstrap的Grid Systemt之前我们先看一下_variables.scss中所涉及的变量： 12345678910111213141516171819202122232425262728293031//_variables.scss$grid-breakpoints: ( // Extra small screen / phone xs: 0, // Small screen / phone sm: 34em, // Medium screen / tablet md: 48em, // Large screen / desktop lg: 62em, // Extra large screen / wide desktop xl: 75em) !default;// Grid containers// 对于不同的屏幕尺寸设置'.container'的最大宽度$container-max-widths: ( sm: 34rem, // 480 md: 45rem, // 720 lg: 60rem, // 960 xl: 72.25rem // 1140) !default;``` 其中$grid-breakpoints的作用是当你选择哪种方式布局时，从而让Grid系统适应各种屏幕尺寸。我们都知道Grid总列数为12列，列与列的宽度为30px(30px分为两部分，分别应用与相邻的两列),这是通过以下变量定义：```css// Grid columns//// 设置列数以及列与列之间的间隔$grid-columns: 12 !default;$grid-gutter-width: 1.875rem !default; // 30px Bootstrap提供两种布局：固定布局与流式布局,实际上就是在外面加了一个容器(container)，固定布局就是container的宽度时固定的，流式布局的container是自适应的。 12345678910111213141516171819202122232425//_grid.scss// 设置container的固定宽度.container &#123; @include make-container(); //对于不同的屏幕尺寸，通过媒体查询来定义每个container的最大宽度 @each $breakpoint, $container-max-width in $container-max-widths &#123; @include media-breakpoint-up($breakpoint) &#123; max-width: $container-max-width; &#125; &#125;&#125;// Fluid container////利用mixin的方法来设置流式布局.container-fluid &#123; @include make-container();&#125;// Row//// 定义row并且清楚列与列之间的浮动.row &#123; @include make-row();&#125;// Columns@include make-grid-columns(); 再来看一下@mixin make-container和@mixin make-row: 123456789101112131415161718//_grid.scss/mixin@mixin make-container($gutter: $grid-gutter-width) &#123; margin-right: auto; margin-left: auto; padding-left: ($gutter / 2); padding-right: ($gutter / 2); @include clearfix();&#125;@mixin make-row($gutter: $grid-gutter-width) &#123; @if $enable-flex &#123; display: flex; flex-wrap: wrap; &#125; @else &#123; @include clearfix(); &#125; margin-left: ($gutter / -2); margin-right: ($gutter / -2);&#125; row中的负margin是对container的padding修正，为什么要这么做呢？我们可以看一下如何定义col的： 1234567891011@mixin make-col($gutter: $grid-gutter-width) &#123; position: relative; @if $enable-flex &#123; // Do nothing &#125; @else &#123; float: left; &#125; min-height: 1px; padding-left: ($gutter / 2); padding-right: ($gutter / 2);&#125; 这里的col也设置了padding，我们都知道列可以嵌套列，也就是说col里面可以加一层row，这样就使得col相当于一个container，从而实现嵌套，是不是很微妙？具体可以看一下这篇文章 .我们知道bootstrap的列示通过类似.col-xs-1,.col-sm-1,col-md-1,col-lg-1…这样的类名定义的，也就是说class被分为四种分辨率，每种分辨率有12个数字，这样就有48种类名，当然除去pull,push,offset，数量是十分多的。所以为了方便编码，sass用了迭代来产生css。首先通过一个占位符设置通用属性： 123456789// Common properties for all breakpoints%grid-column &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: ($gutter / 2); padding-right: ($gutter / 2);&#125; 然后通过两层迭代来设置col： 1234567@each $breakpoint in map-keys($breakpoints) &#123; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column; &#125; &#125;&#125; 输出结果为： 123456789101112131415161718.col-xs-1,.col-sm-1,.col-md-1,.col-lg-1,.col-xs-2,.col-sm-2,.col-md-2,.col-lg-2,.col-xs-3,.col-sm-3,.col-md-3,.col-lg-3,.col-xs-4,.col-sm-4,.col-md-4,.col-lg-4,.col-xs-5,.col-sm-5,.col-md-5,.col-lg-5,.col-xs-6,.col-sm-6,.col-md-6,.col-lg-6,.col-xs-7,.col-sm-7,.col-md-7,.col-lg-7,.col-xs-8,.col-sm-8,.col-md-8,.col-lg-8,.col-xs-9,.col-sm-9,.col-md-9,.col-lg-9,.col-xs-10,.col-sm-10,.col-md-10,.col-lg-10,.col-xs-11,.col-sm-11,.col-md-11,.col-lg-11,.col-xs-12,.col-sm-12,.col-md-12,.col-lg-12 &#123; position: relative; min-height: 1px; padding-right: 15px; padding-left: 15px;&#125; 提取出公共属性后，我们需要将其分配到不同分辨率，是怎么做的呢，这里十分巧妙： 12345678910111213141516171819202122232425262728293031%grid-column &#123; position: relative; // Prevent columns from collapsing when empty min-height: 1px; // Inner gutter via padding padding-left: ($gutter / 2); padding-right: ($gutter / 2); &#125; @each $breakpoint in map-keys($breakpoints) &#123; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column; &#125; &#125; @include media-breakpoint-up($breakpoint) &#123; // Work around cross-media @extend (https://github.com/sass/sass/issues/1050) %grid-column-float-#&#123;$breakpoint&#125; &#123; @if $enable-flex &#123; // Do nothing &#125; @else &#123; float: left; &#125; &#125; @for $i from 1 through $columns &#123; .col-#&#123;$breakpoint&#125;-#&#123;$i&#125; &#123; @extend %grid-column-float-#&#123;$breakpoint&#125;; @include make-col-span($i, $columns); &#125; &#125; &#125; &#125; 可以看出，它是在遍历分辨率尺寸的基础上，使用定义好的media-breakpoint-up的mixin再进行迭代，这里值得注意的一点是，由于之前我们已经生成了.col-#{$breakpoint}-#{$i}的基本属性，所以在进行查询媒体迭代时，@extend %grid-colum-float-#{$breakpoint}会附加在原有的基本属性上。这样就把各种类名分配到了相应的媒体查询上。当然除此之外，还有push、pull、offset之类的其实也差不多，这里就不再重复了。除此之外有一点人们容易忽略的地方是，Grid系统是基于border-box，这点是实现Grid魔法的关键之一： 12345678html &#123; box-sizing: border-box;&#125;*,*:before,*:after &#123; box-sizing: inherit;&#125; normalize.cssBootstrap中使用normalize.css来初始化样式。之前我一直使用reset.css来重置浏览器的默认样式，而normalize.css是reset.css的一种替代方案。之所称其为替代方案，作者necolas介绍时已经把其说的很清楚了： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 简单点说，它和reset.css不同之处在于： Reset是相对‘暴力’的，不管你有用没用，都重置成统一的样式，所有东西都必须一致。 normalize.css却是相对‘平和’的，不求样式一致,尽量保留浏览器的默认样式，尽量不进行太多的重置。 举个简单的栗子，对于简单的一个 h1 标签来说，reset.css可能会做很多事： 12345678910111213141516171819202122//reset.csshtml, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125;... 而nomalize.css只是这样做： 1234567// Address variable `h1` font-size and margin within `section` and `article`// contexts in Firefox 4+, Safari, and Chrome.//h1 &#123; font-size: 2em; margin: 0.67em 0;&#125; 你可以很轻易的看出其中思想上的差别，也就是说，normalize.css的优势在于它保持了许多浏览器的默认样式，当一个元素在不同浏览器中有不同的默认值时，nomalize.css会让样式保持一致并且尽可能的与现代标准相符合；以及修复了常用的桌面端和移动端浏览器的bug，比如HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 对于使用reset.css还是normalize.css，仁者见仁智者见智吧。 写在后面Bootstrap在设计上是非常注重模块化以及层次化的，一方面是利于维护，另一方面提高了可复用性，这点非常值得学习。","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"源码分析","slug":"源码分析","permalink":"stephenliu.site/tags/源码分析/"}]},{"title":"Module.exports vs Exports in Node.js","slug":"Module-exports-vs-Exports-in-Node-js","date":"2017-06-07T16:34:42.000Z","updated":"2017-06-07T16:38:47.000Z","comments":true,"path":"2017/06/08/Module-exports-vs-Exports-in-Node-js/","link":"","permalink":"stephenliu.site/2017/06/08/Module-exports-vs-Exports-in-Node-js/","excerpt":"","text":"前言最近在折腾node.js的时候，经常会看到类似exports.xxx = yyy以及module.exports = yyy这样的代码，可实际上如果通过require()函数来引用模块就会有报错的情况，所以到底是什么原因造成的呢？这两者又有什么区别？关于两者的区别，了解了下面几点就会非常的清楚: exports 是 module.exports 的一个引用 exports = module.exports = {} require()返回的是module.exports 而不是 exports exports.xxx 相当于在导出对象上挂属性，该属性对调用模块直接可见exports =相当于给exports对象重新赋值，调用模块不能访问exports 对象及其属性 如果此模块是一个类，就应该直接赋值给module.exports,这样调用者就是一个类构造器，可以直接使用new实例化；如果只导出简单的属性，可以直接挂载到exports上 比如以下代码计算圆的面积： 使用exports12345678// circle.jsexports.area = function(r)&#123; return r*r*3&#125; ;//app.jsvar circle = require('./circle')console.log(circle.area(2))//输出 '12' 使用module.exports12345678// area.jsmodule.exports = function(r)&#123; return r*r*3&#125;;//app.jsvar area = require('./area')console.log(area(2))//输出 '12' 两者输出是一样的，因为exports是module.exports的一个引用，所以两者指向的内存地址是一样的，可是如果你这样写: 12345678// area.jsexports = function(r)&#123; return r*r*3&#125;;//app.jsvar area = require('./area')console.log(area(2))//输出 'TypeError: object is not a function' 我们可以看到是报错的，原因在于，之前说过require()返回的只是module.exports,而exports是module.exports的一个引用，上面代码给exports重新赋值，使其指向了新的内存地址，此时exports和module.exports毫无关系，也就是说此时module.exports的值为默认值{}，所以导出的是一个空对象。 也就是说，module.exports才是关键，而exports只是起辅助的作用,最终导出来的是module.exports上挂载的对象，当module.exports没有任何值时，exports挂载的属性会赋值给module.exports, 当module.exports具有挂载的对象时，exports上的所有值会被忽略，比如以下代码只输出了module.exports所挂载的属性: 12345678//rock.jsmodule.exports.name = 'Stephen'exports.name = 'Mike'//app.jsvar rock = require('./rock.js')rock.name//输出'Stephen' 总结一下: 如果要导出非对象接口（属性），可以直接使用exports 如果要导出对象接口(类)，应该将其挂载到module.exports上面，从而可以直接让调用者new实例化对象 参考：exports 和 module.exports 的区别node-js-exports-vs-module-exportsmodule-exports-and-exports-in-node-js","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"nodeJs","slug":"nodeJs","permalink":"stephenliu.site/tags/nodeJs/"}]},{"title":"［译］关于vertical-align你应该知道的事","slug":"［译］关于vertical-align你应该知道的事","date":"2017-06-07T07:41:19.000Z","updated":"2017-06-07T15:46:02.000Z","comments":true,"path":"2017/06/07/［译］关于vertical-align你应该知道的事/","link":"","permalink":"stephenliu.site/2017/06/07/［译］关于vertical-align你应该知道的事/","excerpt":"","text":"原文链接：Vertical-Align: All You Need To Know原文作者: Christopher Aue 关于Vertical-Align你应该知道的事我经常会碰到将元素在垂直方向上对齐的需求。 CSS提供了一些可能的方法:有时我会用float来解决这个问题,有时会使用position:absolute,有时甚至不惜手动调整margins或者paddings(这是一件十分dirty的做法)。 实话说我非常不喜欢这些解决方式。浮动只在其顶部对齐并且需要手动清除浮动。绝对定位会使元素脱离文档流,以至于它们不再影响它们周边的元素。对于使用固定的margins和paddings来说即使只是一些微小的变化,那也将成为一场灾难。 但是这里有另一个杀伤力武器 : vertical-align。我认为它值得这个称赞。好吧,从技术角度上讲,使用vertical-align来布局其实是一种hack,原因是它存在并不是为了布局。而是为了使文本元素和与相邻的元素在垂直方向上对齐。尽管如此,在不同的上下文你依然可以非常灵活和细粒化的使用vertical-align来对齐元素。元素的尺寸可以不需要知道,因为元素没有脱离文档流,所以其它元素可以对那些改变的尺寸作出反应。这将使他在布局时成为一个有价值的选择。 Vertical-Align的奇特之处尽管如此,vertical-align有时候可能是面目狰狞的。使用它会令人有点泄气:在它的内部工作机制中似乎有一些神秘的规则。比如有一种很可能发生的情况便是,当你改变了某个元素的vertical-align属性,实际上并没有改变它的对齐方式,但别的元素却发生了变化! 不幸的是,当今大部分有关这方面的资料深入程度都不够。尤其是当我们想用vertical-align来布局的时候。这些资料更多的是将注意力集中在一个误解的概念上-尝试着垂直对齐一个元素内的任何内容。他们仅仅给出基本的介绍以及解释在一些十分简单的情况下元素是如何对齐的。他们并不解释复杂的部分。 所以,我给自己设定了一个目标– 彻彻底底的弄清楚vertical-align 的行为 。我参考了W3C上的CSS规范以及试验了一些例子最终结束了这项任务。这篇文章便是我研究的成果。 那么,让我们来弄清楚这个游戏规则吧! 使用Vertical-align的要求 vertical-align被用于对齐inline元素。这些元素,也就是display属性为inline和inline-block,而inline-table的元素不在本文讨论的范围内。Inline元素基本上指的就是文本。 Inline-block元素顾名思义,同时具备inline以及block元素的特性。这样的元素具有宽度和高度(可能是由内容高度决定),同样还具有padding,margin,boreder。inline元素一个一个挨着摆放在行内。一旦元素太多而超出该行,则一个新行会被创建出来,这些行便是所谓的line-box。它会将行内所有的内容包裹起来。不同大小的内容,line-box的行内高度也会不同。下图画的红线代表了line-box的上下边界。 在这些line-box里vertical-align属性负责对齐那些独立的元素。那么,这些元素是和谁对齐呢? 关于Baselines和边界 关于垂直对齐最重要的一点便是相关元素的baseline。有些情况元素盒模型的上下边界也十分重要。让我们来看看每个相关元素中baseline和边界所在的位置。 上图你可以看到有并排的三行文字。行高的上下边界用红线标出,文字高度用的是绿线,baseline便是蓝线了。左图行高和文字高度一致,所以绿线和红线重合了。中间图行高是文字大小的两倍。右边行高是文字大小的二分之一。行内元素的外界在行高的上下边缘这个范围内对齐。如果行高小于文字高度也无所谓。什么是baseline呢?简单粗暴的说,baseline就是文字高度中线下方的一条线。具体可以看W3C上的介绍标准链接。 inline-block元素 从左到右你可以看到三个inline-block元素:左边是没有脱离文档流的内容c,中间是没有脱离文档流的内容c并且overflow:hidden,右边是没有内容但是内容有高度。margin-box的边界是用红线标出,黄色是border,绿色是padding,蓝色是content。蓝色的线代表的是元素的baseline。inline-block元素的边界就是margin-box的上下边界。 inline-block元素的baseline取决于该元素是否具有处于正常流的内容,具体分以下三种情况: 在具有处于文档流的内容的情况下,inline-block元素的baseline就是最后一个内容元素的baseline(如上图左边)。这个元素的baseline的确定根据去自身规则确定。 在具有处于文档流的内容并且overflow属性的值不为visible的情况下,baseline便是margin-box的下边界(如上图中间)。因此它也是inline-block的下边界。 在不具有处于文档流的内容情况下,baseline同样也是margin-box的下边界。 Line box 关于line-box的图上面已经说过了。这次我将linebox的内容的上下边界(绿线)以及baseline(蓝线)画了出来。同样将内容元素用灰色背景高亮了出来。line-box的上边界和最高元素的上边界对齐,下边界和最低元素的下边界对齐。 line-box的baseline是不确定的 CSS2.1 does not define the position of the line box’s baseline ——the W3C Specs* 这也是当我们使用vertical-align时最令人疑惑的地方。这意味着baseline的位置受其他条件比如vertical-align的值以及让line-box高度最小的影响。这是一个很灵活的参数。 因为line-box的baseline是不可见得,所以可能不能一眼就看出来它在那。不过,你可以很轻易的将它可视化出来。只需要在行的开头添加一个字母。比如添加一个’x’。如果这个字母没有被其他方法来对齐,那么它的下边界默认就是baseline的位置。 在line-box中围绕着baseline会形成text-box。text-box可以简单的被认为是没有和line-box中任何元素对齐的inline元素。它的高度与父元素font-size的值相等。因此,text-box仅仅包含非格式化的line-box文本。text-box的边界由绿线来表示。因为text-box和baseline是绑定的,当baseline位置发生变化时它的位置也会发生变化。(这里所说的text-box在W3C标准中被叫做strut。) hu~这部分比较难理解。让我们总结一下最重要的两点: 有一个叫line-box的区域,垂直方向的对齐都发生在这个区域里。它有baseline,text-box以及上下边界。 inline元素是我们需要对其的对象,他们有baseline和上下边界。 Vertical-Align的值 关于Vertical-align的值具体可以看MDN Vertical-Align是如何发挥它的作用的呢我们现在可以更加深入的了解在某些情况下元素是如何垂直对齐的。 对齐一个Icon这里有一个问题：我想将一个icon与相邻的文本对齐。仅仅将icon的vertical-align属性的值设置为middle并不是一个令人满意的方法。看一下例子： 12345678910111213&lt;!-- left mark-up --&gt;&lt;span class=\"icon middle\"&gt;&lt;/span&gt;Centered?&lt;!-- right mark-up --&gt;&lt;span class=\"icon middle\"&gt;&lt;/span&gt;&lt;span class=\"middle\"&gt;Centered!&lt;/span&gt;&lt;style type=\"text/css\"&gt;.icon &#123; display: inline-block; /* size, color, etc. */ &#125;.middle &#123; vertical-align: middle; &#125;&lt;/style&gt; 下面给出上图的辅助线版本: 这揭示了我们的问题。因为左图的文本根本没有发生对齐行为，它还是和line-box的baseline对齐。而vertical-align对齐的点是baseline加上半个x的距离(half of the x-height)。因此文字的最高点超过了icon的高度。右图所示，文字与icon对齐与一个中点。文字的baseline稍微低于line-box的baseline。结果文字很好的和icon对齐了。 关于Line-box的baseline的移动问题这是一个使用vertical-align常有的坑：line-box里的所有元素都会影响到baseline的位置。让我们假设一下，如果一个元素通过某种方法对齐了，但是line-box的baseline不得不因此移动。因为大部分对齐方式（除了top和bottom）都和baseline有关，因此这个元素的对齐会导致行内其他元素的调整。下面是一些例子： 如果有一个高度可以占满整个line-box高度的元素，那么vertical-align对它是没有影响的。在它的top以上和bottom以下没有空间可以使它移动。为了满足它的vertical-align的值，line-box的baseline需要移动。下图矮盒子的vertical-align:baseline,左边的高盒子取值为text-bottom,右边为text-top，你可以看到矮盒子随着baseline跳了上去。 123456789101112131415&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box,.short-box &#123; display: inline-block; /* size, color, etc. */ &#125;.text-bottom &#123; vertical-align: text-bottom; &#125;.text-top &#123; vertical-align: text-top; &#125;&lt;/style&gt; 当把高元素的vertical-align属性设置成其他值的时候，表现的行为是一样的。 甚至将vertical-align设置成bottom（left）和top（right）也会移动baseline。这很奇怪，因为这应该和baseline并没有什么关系。 123456789101112131415&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box bottom\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box top\"&gt;&lt;/span&gt;&lt;span class=\"short-box\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box,.short-box &#123; display: inline-block; /* size, color, etc. */ &#125;.bottom &#123; vertical-align: bottom; &#125;.top &#123; vertical-align: top; &#125;&lt;/style&gt; 将两个更大的元素放在一行里，然后设置vertical-align的值使其的baseline移动以至于让他们对齐。接着line-box的高度会自动调整。添加第三个元素，这个元素如果不超过line-box的边界，则它不影响line-box的高度以及baseline的位置。如果该元素超过了line-box的边缘，则line-box的高度以及baseline都会调整。在这种情况下，另外两个元素的位置发生了下移。 12345678910111213141516171819202122&lt;!-- left mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;!-- mark-up in the middle --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box middle\"&gt;&lt;/span&gt;&lt;!-- right mark-up --&gt;&lt;span class=\"tall-box text-bottom\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-top\"&gt;&lt;/span&gt;&lt;span class=\"tall-box text-100up\"&gt;&lt;/span&gt;&lt;style type=\"text/css\"&gt;.tall-box &#123; display: inline-block; /* size, color, etc. */ &#125;.middle &#123; vertical-align: middle; &#125;.text-top &#123; vertical-align: text-top; &#125;.text-bottom &#123; vertical-align: text-bottom; &#125;.text-100up &#123; vertical-align: 100%; &#125;&lt;/style&gt; inline元素下方可能会有点间隙来看一个例子。一个常见的情况就是你尝试将列表的li元素垂直对齐。 12345678910&lt;ul&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li class=\"box\"&gt;&lt;/li&gt; &lt;li class=\"box\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style type=\"text/css\"&gt; .box &#123; display: inline-block; /* size, color, etc. */ &#125;&lt;/style&gt; 正如你所看到的，li元素是对齐baseline的。baseline的下方会有一部分留给文字的空间。这便会产生小缝隙。那么解决方案是什么？只要改变line-box的baseline的位置就好了，比如把li元素的vertical-align:middle. 123456789101112&lt;ul&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt; &lt;li class=\"box middle\"&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style type=\"text/css\"&gt; .box &#123; display: inline-block; /* size, color, etc. */ &#125; .middle &#123; vertical-align: middle; &#125;&lt;/style&gt; inline元素之间的间隙会破坏布局效果这主要是inline元素自身的问题。但是因为这是让vertical-align发挥作用的必要因素，所以了解它也是不错的。 这个间隙主要是来源于inline元素之间的空格。所有空白都会变成一个空格。这个空格可以通过该方法反映，比如如果你想让两个inline元素紧挨着，然后给他们的宽度分别设置为50%，这里并没有足够的空间存放两个宽度为50%的元素以及一个空格。所以一行便会被破坏成两行。为了移除空隙，我需要移除空格，解决方案如下： 123456789101112&lt;!-- left mark-up --&gt;&lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;div class=\"half\"&gt;50% wide... and in next line&lt;/div&gt;&lt;!-- right mark-up --&gt; &lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;!----&gt;&lt;div class=\"half\"&gt;50% wide&lt;/div&gt;&lt;style type=\"text/css\"&gt; .half &#123; display: inline-block; width: 50%; &#125;&lt;/style&gt; Vertical-align揭秘是的，对于你来说了解这些规则并不复杂。如果vertical-align不起作用，那么想想看这两个问题： line-box的baseline以及上下边缘位置在哪里？ inline元素的baseline以及上下边缘在哪里？","categories":[{"name":"Technology","slug":"Technology","permalink":"stephenliu.site/categories/Technology/"}],"tags":[{"name":"translate","slug":"translate","permalink":"stephenliu.site/tags/translate/"}]}]}